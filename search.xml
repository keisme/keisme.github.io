<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Combin 简明教程一： Publisher、Subscriber]]></title>
    <url>%2FCombine-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B%E4%B8%80%EF%BC%9A-Publisher%E3%80%81Subscriber.html</url>
    <content type="text"><![CDATA[Source Code Publisher 用于向订阅者发布数据，Subscriber 用于接收订阅的发布者发布的数据。 PublisherCombine 框架为我们提供了许多便利的 Publisher。 SwiftUI 经常使用的属性包装器 @Published 和 @ObservedObject，源自 Combine，它们会隐式创建 Publisher。关于 SwiftUI 中的属性包装器，可以参考SwiftUI 中常见的属性包装器（Property Wrapper）概览。 Future使用闭包初始化，并立即执行闭包，异步返回单个值或失败的结果，发布就结束了。 123456789101112131415161718192021222324252627282930313233343536enum SomeError: Error &#123; case someError var localizedDescription: String &#123; return "Some Error" &#125;&#125;struct FutureView: View &#123; @State private var buttonTitle = "Tap me!" var body: some View &#123; Button(buttonTitle) &#123; let publisher = Future&lt;String, SomeError&gt;(&#123; (promise) in if Bool.random() &#123; promise(.success("Succeed")) &#125; else &#123; promise(.failure(.someError)) &#125; &#125;) _ = publisher.sink(receiveCompletion: &#123; switch $0 &#123; case .finished: print($0) case .failure(let error): print(error) self.buttonTitle = error.localizedDescription &#125; &#125;, receiveValue: &#123; print($0) self.buttonTitle = $0 &#125;) &#125; &#125;&#125; JustJust 是非异步的，它会向订阅者发送一个值，并且只发送一次，然后就结束了。Just 关联的 Failure 类型是 Never，表明它永远不会返回失败的结果。 1234Button("Just tap me!") &#123; _ = Just("You have tapped!") .sink(receiveCompletion: &#123; print($0) &#125;) &#123; print($0) &#125;&#125; DeferredDefered 使用一个 Publisher 初始化，生成一个新的 Publisher，可以延迟执行被包装的 Publisher 的闭包。比如 Future ，它在创建的时候，就立即执行闭包了。如果我们不希望它立即执行，可以使用 Deferred 包装一下，然后在订阅者需要发送数据的时候，才执行数据的发布行为。 Empty永远不会产生数据流的 Publisher，可以立即结束，或不会结束。 1234567let flag = Bool.random()print(flag)// completeImmediately// If `true`, the publisher finishes immediately after sending asubscription to the subscriber. If `false`, it never completes._ = Empty&lt;String, Never&gt;(completeImmediately: flag).sink(receiveCompletion: &#123; print($0) &#125;, receiveValue: &#123; print($0) &#125;) Fail发布指定的错误，并立即结束发布事件。 Record记录一系列的值，发布给订阅者。 Subscriber在上面的实例中，其实我们已经使用过 Subscriber 了，那就是 sink 。 Combine 内建了两个 Subcriber：sink(_:_:) 和 assign(to:on:)，sink 无需多说了。 assignassign 可以将发布者的输出值分发给一个对象的属性，前提是该属性可以通过 KVO 监听。 12345678910111213141516class SomeObject &#123; var value: String = "" &#123; didSet &#123; print(value) &#125; &#125;&#125;let obj = SomeObject()let pub = ["Hello", "world!"].pub_ = pub.assign(to: \.value, on: oprint(obj.value) // Hello// world!// world! onReceiveSwiftUI 内建的 Subcriber，用于接收订阅的 Publisher 发送的数据。 比如： 1234567891011121314Text("Hello world!").onReceive(NotificationCenter.default.publisher(for: UIApplication.willResignActiveNotification)) &#123; _ in&#125;Text("Hello world!").onReceive(NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification)) &#123; _ in&#125;Text("Hello world!").onReceive(timer) &#123; time in &#125; 其它AnyPublisherAnyPublisher 可以隐藏 Publisher 内部的实现细节，通常我们会用 eraseToAnyPublisher() 将 Publisher 的类型擦除，使其成为 AnyPublisher。 AnySubscriberAnySubscriber 与 AnyPublisher 有相似的作用。 AnyCancellableSubcriber 都是遵循 Cancellabel 协议的，手动调用 cancel() 可以释放分配的资源。 使用 AnyCancellable 可以擦除其类型，AnyCancellable 类型的实例会在 deinitialized 时自动调用 cancel()。通常我们会在某个对象内用一个集合（Set）去保存 AnyCancellable 实例，当这个对象 deinitialized 时，集合里的 AnyCancellable 实例也会随之释放。 Source Code]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>combine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftUI 中常见的属性包装器（Property Wrapper）概览]]></title>
    <url>%2FSwiftUI-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8C%85%E8%A3%85%E5%99%A8%EF%BC%88Property-Wrapper%EF%BC%89%E6%A6%82%E8%A7%88.html</url>
    <content type="text"><![CDATA[​ Demo @State由 SwiftUI 管理的可读写的属性包装器，当修饰的属性值改变的时候，界面会随之更新。由 @State 包装的属性通常用 private 修饰，在 body 内使用。 下面的实例是一个可以切换天气的界面，并且可以控制天气是否可变。 1234567891011121314151617181920212223242526272829303132333435363738394041424344enum Weather: String, CaseIterable &#123; case sun = "Sun" case cloud = "Cloud" case rain = "Rain" case snow = "Snow" var imageName: String &#123; switch self &#123; case .sun: return "sun.max" case .cloud: return "cloud" case .rain: return "cloud.rain" case .snow: return "snow" &#125; &#125;&#125;struct StateView: View &#123; @State private var weather: Weather = .sun @State private var mutableWeather = false var body: some View &#123; VStack &#123; Toggle(isOn: $mutableWeather) &#123; Text(mutableWeather ? "Mutable" : "Immutable") &#125; .padding() // add weather view Spacer() &#125; .navigationBarTitle("Weather", displayMode: .inline) .navigationBarItems(trailing: Button(action: &#123; if self.mutableWeather &#123; let random = Int.random(in: 0..&lt;Weather.allCases.count) self.weather = Weather.allCases[random] &#125; &#125;) &#123; Text(weather.rawValue) &#125;) &#125;&#125; @Binding接下来，我们用自定义的 WeatherView 去展示天气图片，图片会跟随父视图天气变化做相应改变，并且在 WeatherView 中可以通过点击改变天气。这个时候，我们就需要用到 @binding 来做数据的双向绑定。 12345678910111213141516struct WeatherView: View &#123; @Binding var weather: Weather @Binding var mutableWeather: Bool var body: some View &#123; Image(systemName: weather.imageName) .resizable() .scaledToFill() .frame(width: 150, height: 150) .onTapGesture &#123; self.mutableWeather = true let random = Int.random(in: 0..&lt;Weather.allCases.count) self.weather = Weather.allCases[random] &#125; &#125;&#125; 接下来我们在 // add weather view下面添加如下代码： 1WeatherView(weather: $weather, mutableWeather: $mutableWeather) @ObservedObject、@Published、ObservableObject遵循 ObservableObject 协议的类的属性可以用 @Published 包装，在多个界面之间同步数据，只需要将需要监听的实例对象用 @ObservedObject 包装即可。注意：这里适用的对象类型是 class，因为 class 是在内存中共享数据的。 下面是一个可以编辑一个人姓名和年龄的实例，在 EditView 所做的更改，会同步至 Person 界面。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Person: ObservableObject &#123; @Published var name: String @Published var age: Int init(name: String, age: Int) &#123; self.name = name self.age = age &#125;&#125;struct EditView: View &#123; @ObservedObject var person: Person var body: some View &#123; // TextField 只能绑定 String，需要自定义 Binding let bindingAge = Binding&lt;String&gt;(get: &#123; "\(self.person.age)" == "0" ? "" : "\(self.person.age)" &#125;) &#123; value in self.person.age = Int(value) ?? 0 &#125; return Form &#123; TextField("Input name", text: $person.name) TextField("Input age", text: bindingAge) &#125; &#125;&#125;struct ObservedObjectView: View &#123; @ObservedObject private var person = Person(name: "Bruce", age: 30) var body: some View &#123; List &#123; Text(person.name) Text("\(person.age)") &#125; .navigationBarTitle("Person", displayMode: .inline) .navigationBarItems(trailing: NavigationLink(destination: EditView(person: self.person)) &#123; Text("Edit") &#125; ) &#125;&#125; @Environment、EnvironmentValues@Environment 可以让我们在 View 中直接访问预设的环境变量，比如系统是否暗黑模式、系统日历、时区等。 下面是一个可以返回上一个页面的实例，@Environment将.presentationMode绑定在当前的 View，我们可以直接调用presentationMode来获取它的值： 123456789struct EnvironmentView: View &#123; @Environment(\.presentationMode) private var presentationMode var body: some View &#123; Button("Dismiss") &#123; self.presentationMode.wrappedValue.dismiss() &#125; &#125;&#125; 系统为我们提供了许多有用的预设变量，详见 https://developer.apple.com/documentation/swiftui/environmentvalues 我们也可以为预设值注入新值，比如我们将返回按钮标题改为 “Dismiss\nDismiss”，这时可以看见一个换行的按钮，而当我们给.lineLimit注入新值得时候，按钮标题就只有一行了： 1234Button("Dismiss\nDismiss") &#123; self.presentationMode.wrappedValue.dismiss()&#125;.environment(\.lineLimit, 1) 这里只是举个例子，我们使用.lineLimit(1)也能达到同样的效果。 我们也可以自定义 EnvironmentValues： 12345678910struct DismissColorKey: EnvironmentKey &#123; public static let defaultValue = Color.red&#125;extension EnvironmentValues &#123; var dismissColor: Color &#123; set &#123; self[DismissColorKey.self] = newValue &#125; get &#123; self[DismissColorKey.self] &#125; &#125;&#125; 然后我们添加一个新的属性： 1@Environment(\.dismissColor) private var dismissColor 再使用自定义的预设值添加一个红色的返回按钮： 123456Button(action: &#123; self.presentationMode.wrappedValue.dismiss()&#125;) &#123; Text("Red Dismiss") .foregroundColor(dismissColor)&#125; @EnvironmentObject@EnvironmentObject 和 @ObservedObject 很像，都需要遵循 ObservableObject 协议，都可以同步数据状态，但是它具备更强大的功能，那就是子视图可以自动获取父视图注入的环境变量。 比如我们有如下视图层级：A -&gt; B -&gt; C -&gt; D -&gt; E，后一个是前一个视图的子视图。如果我们使用 @ObservedObject 在 A 视图包装一个变量，我们需要在每个视图包装一个变量，将变量一层层传递到 E 视图。而使用 @EnvironmentObject 我们不需要这么复杂，我们在 A 视图声明一个变量后，在 E 视图用 @EnvironmentObject 包装一个变量后，就可以获取到 A 视图注入的环境变量了，而且可以同步数据的修改，这简直是太方便了。要注意的是，如果 E 视图找不到这个环境变量，程序会崩溃，所以要确保 E 视图能获取到注入的环境变量。 12345678910111213141516171819202122232425262728293031323334353637class User: ObservableObject &#123; @Published var name = "Bruce"&#125;struct ViewA: View &#123; var body: some View &#123; ViewB() .frame(width: 300, height: 300) .background(Color.red) &#125;&#125;struct ViewB: View &#123; var body: some View &#123; ViewC() .frame(width: 200, height: 200) .background(Color.black) &#125;&#125;struct ViewC: View &#123; @EnvironmentObject var user: User var body: some View &#123; Text(user.name) .frame(width: 100, height: 100) .background(Color.white) &#125;&#125;struct EnvironmentObjectView: View &#123; private let user = User() var body: some View &#123; ViewA().environmentObject(user) &#125;&#125; ​ Demo]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>swiftui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App Store 提交审核被拒记录]]></title>
    <url>%2FApp-Store-%E6%8F%90%E4%BA%A4%E5%AE%A1%E6%A0%B8%E8%A2%AB%E6%8B%92%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[ITMS-90809: Deprecated API Usage最近提交的 App 遇到了这个问题，邮件中提到的是被废弃的 UIWebView API，在工程中全局搜索后没有找到 UIWebView。想来必然是第三方静态库使用了，在工程目录下使用命令grep -r UIWebView .查看哪些库使用了 UIWebView，移除或升级相关库即可。 ITMS-90381: Too many symbol files项目本身设置了 Valid Architecture 为 arm64、arm64e，但是因为使用了支持 32 位设备的三方库，所以生成了冗余的 symbols 文件。 查询 symbols 文件的生成情况：Xcode Window -&gt; Organizer 选择有问题的 archive，右击选择 Show in finder，命令行进入 .app 中的 dSYMs 文件夹，执行 `dwarfdump –uuid ` 可以查询到是否生成了多余的文件。 解决方法是在 Podfile 中添加如下内容： 1234567post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings['DEBUG_INFORMATION_FORMAT'] = 'dwarf' end endend 在platform :ios, &#39;12.0&#39;这一行下面添加即可，然后重新pod install --verbose。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>App Store</tag>
        <tag>审核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter PATH（fish shell）设置和镜像设置]]></title>
    <url>%2FFlutter-PATH%EF%BC%88fish-shell%EF%BC%89%E8%AE%BE%E7%BD%AE%E5%92%8C%E9%95%9C%E5%83%8F%E8%AE%BE%E7%BD%AE.html</url>
    <content type="text"><![CDATA[如果你在 Mac 下使用的 fish shell，按照官方教程设置 flutter 的路径是不会永久生效的。解决方法如下： vi ~/.config/fish/config.fish 写入如下内容： 1set PATH &lt;flutter安装路径&gt;/flutter/bin $PATH 使用echo $PATH查看，发现已经生效，即使退出终端再次打开，依然能正常使用 flutter 的相关命令。 安装好 flutter 后，使用flutter doctor命令，结果一直卡住不动了。。。后来才明白是 TC 的网络问题，参考官方的设置镜像即可。]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>mirror</tag>
        <tag>path</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftFormat 的使用]]></title>
    <url>%2FSwiftFormat-%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[虽然 Xcode 自带格式对齐（Ctrl + i），但是在多人协作的情况下，就很难保证编码风格的统一了，SwiftFormat就是解决这一问题的好工具。 SwiftFormat具有多种使用方式，目前我在实际工作中使用的是CocoaPods集成。具体使用方法： pod &#39;SwiftFormat/CLI&#39;，安装 SwiftFormat TARGETS - Build Phases - New Run Script Phase，添加如下脚本： 1"$&#123;PODS_ROOT&#125;/SwiftFormat/CommandLineTool/swiftformat" . --exclude Pods,Generated 在编译或运行的时候，SwiftFormat会对齐不符合格式的代码。Enjoy it~]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode 创建自定义文件模板]]></title>
    <url>%2FXcode-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6%E6%A8%A1%E6%9D%BF.html</url>
    <content type="text"><![CDATA[首先，创建我们的自定义模板文件夹： 1mkdir -p ~/Library/Developer/Xcode/Templates/Custom 然后复制系统提供的模板文件，路径如下： 1/Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates/File Templates/Source/Swift File.xctemplate 将Swift File.xctemplate整个文件夹复制到刚才创建的Custom文件夹。 然后我们开始自定义，只需要修改___FILEBASENAME___.swift中的内容即可。 其中涉及到一些宏定义可以参考：Text macros reference。注意：宏定义前后必须加上三个下划线。 然后我们就可以使用了，如图：]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义 Xcode 文件头部注释]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89-Xcode-%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8%E6%B3%A8%E9%87%8A.html</url>
    <content type="text"><![CDATA[首先，用 Xcode 创建一个 plist 文件：IDETemplateMacros.plist。 在新建的 plist 文件中，添加键值对。key 为 FILEHEADER，value 参考 IDETemplateMacros.plist中的内容。 其中，FILENAME、PACKAGENAME等为宏定义，更多宏定义请可以通过 Xcode - Help 搜索“Text macros reference”获得。这里要注意的是，宏定义的前后必须要加上三个下划线。 然后我们将编辑好的 plist 文件放入指定的路径，关于路径有以下选择，对应不同的作用范围： Project - 某个用户 1&lt;ProjectName&gt;.xcodeproj/xcuserdata/[username].xcuserdatad/ Project - 所有用户 1&lt;ProjectName&gt;.xcodeproj/xcshareddata/ Workspace - 某个用户 1&lt;WorkspaceName&gt;.xcworkspace/xcuserdata/[username].xcuserdatad/ Workspace - 所有用户 1&lt;WorkspaceName&gt;.xcworkspace/xcshareddata/ Xcode -全局 1~/Library/Developer/Xcode/UserData/ 所有的工作已经完成了，试试创建一个新的文件看看效果吧！]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卸载 CocoaPods（Uninstall CocoaPods）]]></title>
    <url>%2F%E5%8D%B8%E8%BD%BD-CocoaPods%EF%BC%88Uninstall-CocoaPods%EF%BC%89.html</url>
    <content type="text"><![CDATA[使用命令卸载： 1sudo gem uninstall cocoapods 最新版本的 MacOS 可能会提示错误： 12ERROR: While executing gem ... (Gem::FilePermissionError) You don't have write permissions for the /usr/bin directory. 用以下命令可以解决： 1$ sudo gem uninstall -n /usr/local/bin cocoapods 然后查看本机安装的 cocoapods 相关的东西： 1$ gem list --local | grep cocoapods 一般会有如下显示： 12345678cocoapods-core (1.9.1, 1.8.4)cocoapods-deintegrate (1.0.4)cocoapods-downloader (1.2.2)cocoapods-plugins (1.0.0)cocoapods-search (1.0.0)cocoapods-stats (1.1.0)cocoapods-trunk (1.4.1)cocoapods-try (1.1.0) 然后使用命令逐个删除，比如： 1$ sudo gem uninstall cocoapods-core 或 1sudo gem uninstall -n /usr/local/bin cocoapods-core 卸载完成后重新安装即可。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 命名空间（namespace）的实现]]></title>
    <url>%2FSwift-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%88namespace%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/// 实例对象的包装器public struct CCWrapper&lt;WrappedType&gt; &#123; /// 包装后的值 let wrappedValue: WrappedType init(wrappedValue: WrappedType) &#123; self.wrappedValue = wrappedValue &#125;&#125;/// 命名空间协议public protocol NameSpaceWrapper &#123; associatedtype WrapperType var cc: WrapperType &#123; get &#125; static var cc: WrapperType.Type &#123; get &#125;&#125;/// 命名空间协议默认实现public extension NameSpaceWrapper &#123; var cc: CCWrapper&lt;Self&gt; &#123; return CCWrapper(wrappedValue: self) &#125; static var cc: CCWrapper&lt;Self&gt;.Type &#123; return CCWrapper.self &#125;&#125;// 使用extension String: NameSpaceWrapper &#123;&#125;extension CCWrapper where WrappedType == String &#123; var hi: String &#123; return "Hi, I'm \(self.wrappedValue)" &#125; func sayHi(to person: String) &#123; print("\(self.wrappedValue) say hi to \(person)") &#125; static func hi(_ person: String) &#123; print("Hi, \(person)") &#125; &#125;print("Bruce".cc.hi)//Hi, I'm Bruce"Bruce".cc.sayHi(to: "Max")//Bruce say hi to MaxString.cc.hi("Jack")//Hi, Jack]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 关联类型（associatedtype）的使用]]></title>
    <url>%2FSwift-%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B%EF%BC%88associatedtype%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[定义一个协议时，有时在协议定义里声明一个或多个关联类型是很有用的。关联类型给协议中用到的类型一个占位符名称。直到采纳协议时，才指定用于该关联类型的实际类型。关联类型通过 associatedtype 关键字指定。 举个例子： 12345678910111213141516171819202122232425protocol Eat &#123; associatedtype FoodType func eat(_ food: FoodType) -&gt; FoodType&#125;protocol Food &#123; var weight: CGFloat &#123; get set &#125; var desc: String &#123; get set &#125;&#125;struct Meat: Food &#123; var weight: CGFloat var desc: String&#125;struct Vegetable: Food &#123; var weight: CGFloat var desc: String&#125;struct Person&lt;T&gt;: Eat &#123; func eat(_ food: Food) -&gt; Food &#123; return food &#125;&#125; 我们定义了一个 Person，它每天都得吃饭，我们要求它遵循吃饭的协议 Eat，并实现了其中的 eat 方法。在协议 Eat 中我们声明了一个关联类型 FoodType。当 Person 的实例去调用 eat 方法时，我们使用泛型类型去指定之前的占位符 FoodType，那么我们就能清晰地知道 Person 的实例到底吃的是什么。 123456789let p = Person&lt;Food&gt;()let food1 = p.eat(Meat(weight: 1.2, desc: "meat"))print("eat \(food1.desc), weight \(food1.weight)")// eat meat, weight 1.2let food2 = p.eat(Vegetable(weight: 0.8, desc: "meat"))print("eat \(food2.desc), weight \(food2.weight)")// eat meat, weight 0.8]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 终端配置：fish + omf]]></title>
    <url>%2FMac-%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%EF%BC%9Afish-omf.html</url>
    <content type="text"><![CDATA[安装与配置 fish根据官网：https://fishshell.com/ 指引安装即可。 安装完之后，使用命令sudo vim /etc/shells打开配置文件，在文末加上/usr/local/bin/fish，保存退出。 运行chsh -s /usr/local/bin/fish命令使fish成为默认 shell。 使用fish_config配置主题，这里我选Solarized Dark。 安装 oh my fishcurl -L https://get.oh-my.fish | fish 安装之后，使用omf install eclm主题即可。 其它终端描述文件： https://github.com/altercation/solarized 下载后导入名为 Solarized Dark ansi 的配置文件。]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>终端</tag>
        <tag>fish</tag>
        <tag>omf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 查看某个文件的修改历史]]></title>
    <url>%2FGit-%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2.html</url>
    <content type="text"><![CDATA[查看某文件的修改记录git lg [filename] 查看某文件所有变更历史git lg -p [filename] 查看某文件在某次提交中的变更历史git show &lt;commit-id&gt; [filename] 恢复某个文件至某个版本git checkout &lt;commit-id&gt; [filename] lg = log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods 1.8.4 CDN 无法使用的问题]]></title>
    <url>%2FCocoapods-1-8-4-CDN-%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[好久没升级 Cocoapods 了，正好想升级一下，看到 官方文档 的视频演示，满心欢喜地去试用 CDN 。结果，心灰意冷了。 尝试了很多方法，仍然无法使用卖家秀一样的新特性。更可恨的是，我已经使用了 pod repo remove master 命令了。 经过几个小时的折腾后，放弃了。。。 看到 github 上有人提了同样的 issue ，给出的解决方案是不要使用 trunk，而是继续使用 master 库。希望这个 issue 能早日解决吧~ 不得已，删除了 trunk (pod repo remove trunk)，使用 镜像站点 重装了 cocoapods。 由于 Cocoapods 1.8.4 默认使用 CDN 来安装依赖，如果要用回原来的 master 库，需要指定 Podfile 的 source： 123456789101112131415# Uncomment the next line to define a global platform for your projectplatform :ios, '12.0'# source 'https://github.com/CocoaPods/Specs.git'source 'https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git'target 'test' do # Comment the next line if you don't want to use dynamic frameworks # pod 'ImagesView' pod 'Kingfisher' pod 'SnapKit' use_frameworks! # Pods for testend]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Socks5 to http]]></title>
    <url>%2FSocks5-to-http.html</url>
    <content type="text"><![CDATA[安装和配置1brew install porivoxy 安装后，编辑 /usr/local/etc/privoxy/config，搜索socks5找到下面这句： 1#forward-socks5t / 127.0.0.1:9050 . 在下面添加： 1forward-socks5 / 127.0.0.1:port . port 为本机的 ss 代理的 socks5 端口。 配置文件中还有另外一句默认的： 1listen-address 127.0.0.1:8118 这表示 privacy 只监听本机的 8118 端。 开机启动1sudo brew services start privoxy 验证是否启动通过命令查看： 1netstat -an | grep 8118 使用Go 环境配置go get可能无法安装被墙的包，在完成以上步骤后，编辑~/.bash_profile文件，添加： 12export http_proxy=http://127.0.0.1:8118export https_proxy=http://127.0.0.1:8118 然后就可以成功的go get了。 VSCodeVSCode 安装插件的时候会失败，设置代理即可： 12"http.proxy": "http://127.0.0.1:8118","http.proxyStrictSSL": false]]></content>
      <categories>
        <category>trick</category>
      </categories>
      <tags>
        <tag>trick</tag>
        <tag>socks5, http, proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go Modules]]></title>
    <url>%2FGo-Modules.html</url>
    <content type="text"><![CDATA[简介Go modules是随着 Go 1.11 发布的新型的包管理工具，这也是官方推荐的。有了go mod，项目将不再依赖于GOPATH，你可以在任何路径下创建和管理项目，但是下载的依赖包仍然会存储在$GOPATH/pkg/mod路径。 使用配置在 Mac 下，编辑~/.bash_profile文件，写入export Go111MODULE=on 初始化 Modules在项目路径下，使用命令 go mod init &lt;packagename&gt;初始化 编辑 go.mod初始化的 go.mod 会显示如下内容： 1module packagename 添加依赖后： 123456module packagenamerequire ( github.com/test/A v1.2.3 github.com/test/B v1.2.3) 如果你不知道要依赖的版本，可以使用 latest代替版本号，在安装依赖时，go 会自动安装最新的版本。 go.mod 有四种指令： module：模块名称 require：依赖包列表以及版本 exclude：禁止依赖包列表（仅在当前模块为主模块时生效） replace：替换依赖包列表 （仅在当前模块为主模块时生效） 下载依赖包执行go get会下载指定的依赖包 其它命令： go get -u：更新至最新的版本 go get v -u=patch：只更新小的修订版本，例如从 v1.2.3 到 v1.2.4 go get github/com/test/test@v1.2.3：更新至指定版本 go mod vendorgo mod vendor将会复制 modules 到项目的 vendor 文件下，貌似只会复制代码中引用的库，而不是 go.mod 中定义的全部 modules go mod helpgo mod help会显示 go mod 命令帮助： 12345678download 下载依赖的module到本地cacheedit 编辑go.mod文件graph 打印模块依赖图init 再当前文件夹下初始化一个新的module, 创建go.mod文件tidy 增加丢失的module，去掉未用的modulevendor 将依赖复制到vendor下verify 校验依赖why 解释为什么需要依赖]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>modules</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift泛型和闭包的结合使用(Generic Closure)]]></title>
    <url>%2FSwift%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8-Generic-Closure.html</url>
    <content type="text"><![CDATA[1234567typealias Closure = (Any?) -&gt; ()var closure: Closure?func closure(closure: @escaping closure) &#123; self. closure = closure&#125; 通常我们会用如上方式使用闭包，但是最后会导致工程里面的typealias满天飞，这时候我们会想，有没有办法把这部分代码抽取出来一劳永逸呢？这时候，泛型就派上用场了。 我们对上面的闭包类型作如下定义： 1public typealias Closure&lt;T&gt; = (T) -&gt; () 然后在需要用到闭包的地方添加该类型的属性和对应的回调方法即可： 123456789101112131415var btn1Cls: Closure&lt;String&gt;?var btn2Cls: Closure&lt;(msg: String, code: Int, person: Person)&gt;?var voidCls: Closure&lt;()&gt;? func btn1Cls(btn1Cls: @escaping Closure&lt;String&gt;) &#123; self.btn1Cls = btn1Cls&#125; func btn2Cls(btn2Cls: @escaping Closure&lt;(msg: String, code: Int, person: Person)&gt;) &#123; self.btn2Cls = btn2Cls&#125; func voidCls(voidCls: @escaping Closure&lt;()&gt;) &#123; self.voidCls = voidCls&#125; 详细代码见：GenericClosure]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>swift</tag>
        <tag>泛型</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go concurrency(并发)]]></title>
    <url>%2FGo-concurrency-%E5%B9%B6%E5%8F%91.html</url>
    <content type="text"><![CDATA[1. 简介goroutine 是 Go 中的并发执行单位，可以理解为“线程”，但它不是“线程”。生成一个 goroutine 非常简单，只需 go 一下就实现了。在同一个程序中所有的 goroutine 共享一个地址空间。goroutine 通过通信来共享内存，而不是共享内存来通信。 channel 是各个 goroutine 之间通信的管道，它是引用类型，可以使用 == 进行比较，如果引用了相同的数据结构，则结果为真。传数据用 channel &lt;- data，取数据用 &lt;- channel。多数情况下，它是阻塞同步的。channel 可以设置为单向或双向，也可以设置缓存大小，在未被填满前不会发生阻塞。 select 可处理一个或多个 channel 的发送与接收，同时有多个可用的 channel 时按随机顺序处理。 2. 基本使用样例 1 ： 1234567891011121314package mainimport ( "fmt")func main() &#123; ch := make(chan bool) go func() &#123; fmt.Println("Go go go!") ch &lt;- true &#125;() &lt;- ch&#125; go func() 启动了一个 goroutine，main 函数执行到 &lt;- ch 时会一直等待直到取得管道中的值，当打印出 “Go go go!“ 之后，才会传递值到管道中，这时候，程序才执行结束。这是一个简单的示例，我们不需要手动关闭管道，程序结束后占用的资源会自动释放。 样例 2 ： 12345678910111213141516171819package mainimport ( "fmt")func main() &#123; ch := make(chan bool) go func() &#123; fmt.Println("Go go go!") ch &lt;- true close(ch) &#125;() for v := range ch &#123; fmt.Println(v) // print "true" &#125;&#125; for range 会不断地迭代管道中的值，知道管道被关闭。如果我们删掉 close(ch) 这行代码，会导致死锁。 2. 设置缓存无缓存是同步阻塞的，有缓存是异步的。 样例 3 ： 1234567891011121314151617181920212223242526272829package mainimport ( "fmt" "runtime")func main() &#123; // 多核运行 runtime.GOMAXPROCS(runtime.NumCPU()) ch := make(chan bool, 10) for i := 0; i &lt; 10; i++ &#123; go Go(ch, i) &#125; for i := 0; i &lt; 10; i++ &#123; &lt;- ch &#125;&#125;func Go(ch chan bool, index int) &#123; a := 1 for i := 0; i &lt; 100000000; i++ &#123; a += 1 &#125; fmt.Println(a) ch &lt;- true&#125; 上例设置了一个缓存为 10 的管道，实现了多个 goroutine 的并发执行。除了 channel ，我们还可以用 WaitGroup 实现同样的效果，见样例 4 。 样例 4 ： 123456789101112131415161718192021222324252627282930package mainimport ( "fmt" "runtime" "sync")func main() &#123; // 多核运行 runtime.GOMAXPROCS(runtime.NumCPU()) wg := sync.WaitGroup&#123;&#125; wg.Add(10) for i := 0; i &lt; 10; i++ &#123; go Go(&amp;wg) &#125; wg.Wait()&#125;func Go(wg *sync.WaitGroup) &#123; a := 1 for i := 0; i &lt; 100000000; i++ &#123; a += 1 &#125; fmt.Println(a) wg.Done()&#125; 3. select 的用法select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个只能用于 channel 的通信操作，要么是发送要么是接收。 select 如果满足多个分支条件，则会随机执行一个 case 。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。 样例 5 : 123456789101112131415161718192021222324252627282930package mainimport ( "fmt" "time")func main() &#123; c1 := make(chan string) c2 := make(chan string) go func() &#123; time.Sleep(1 * time.Second) c1 &lt;- "one" &#125;() go func() &#123; time.Sleep(2 * time.Second) c1 &lt;- "two" &#125;() for i := 0; i &lt; 2; i++ &#123; select &#123; case msg1 := &lt;- c1: fmt.Println("received", msg1) case msg2 := &lt;- c2: fmt.Println("received", msg2) &#125; &#125;&#125; 样例 6 ： 12345678910111213141516171819202122232425262728package mainimport "fmt"func fibonacci(c, quit chan int) &#123; x, y := 0, 1 for &#123; select &#123; case c &lt;- x: x, y = y, x+y case &lt;-quit: fmt.Println("quit") return &#125; &#125;&#125;func main() &#123; c := make(chan int) quit := make(chan int) go func() &#123; for i := 0; i &lt; 10; i++ &#123; fmt.Println(&lt;-c) &#125; quit &lt;- 0 &#125;() fibonacci(c, quit)&#125;]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go reflection(反射)]]></title>
    <url>%2FGo-reflection-%E5%8F%8D%E5%B0%84.html</url>
    <content type="text"><![CDATA[1. 反射的基本使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package mainimport ( "fmt" "reflect")type User struct &#123; Id int Name string Age int&#125;func (u User) Hello() &#123; fmt.Println("Hello, world")&#125;func Info(o interface&#123;&#125;) &#123; t := reflect.TypeOf(o) fmt.Println("type:", t.Name()) // print "type: User" if k := t.Kind(); k != reflect.Struct &#123; fmt.Println("类型错误") return &#125; v := reflect.ValueOf(o) fmt.Println("fields:") for i := 0; i &lt; t.NumField(); i++ &#123; f := t.Field(i) val := v.Field(i).Interface() fmt.Printf("%6s: %v = %v\n", f.Name, f.Type, val) &#125; // print // fields: // Id: int = 1 // Name: string = ok // Age: int = 12 for i := 0; i &lt; t.NumMethod(); i++ &#123; m := t.Method(i) fmt.Printf("%6s: %v\n", m.Name, m.Type) &#125; // print "Hello: func(main.User)"&#125;func main() &#123; u := User&#123;1, "ok", 12&#125; Info(u)&#125; 注意：User 中的属性必须为大写程序才能正常运行，Go 是根据属性的首字母大小写来确定访问权限的，大写表示公有，小写表示私有。同理，方法签名 Hello 为小写，一样无法反射出对应的方法名。 2. 通过反射修改属性的值123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( "fmt" "reflect")type User struct &#123; Id int Name string Age int&#125;func main() &#123; u := User&#123;1, "ok", 12&#125; Set(&amp;u) fmt.Println(u)&#125;func Set(o interface&#123;&#125;) &#123; v := reflect.ValueOf(o) if v.Kind() == reflect.Ptr &amp;&amp; v.Elem().CanSet() &#123; v = v.Elem() &#125; else &#123; return &#125; f := v.FieldByName("Name") if !f.IsValid() &#123; fmt.Println("Not found") return &#125; if f.Kind() == reflect.String &#123; f.SetString("BYE") &#125;&#125; 3. 通过反射动态调用方法1234567891011121314151617181920212223242526package mainimport ( "fmt" "reflect")type User struct &#123; Id int Name string Age int&#125;func (u User) Hello(name string) &#123; fmt.Println("Hello", name, ", my name is", u.Name)&#125;func main() &#123; u := User&#123;1, "ok", 12&#125; v := reflect.ValueOf(u) mv := v.MethodByName("Hello") args := []reflect.Value&#123;reflect.ValueOf("john")&#125; mv.Call(args) //print "Hello john , my name is ok"&#125;]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go interface(接口)]]></title>
    <url>%2FGo-interface-%E6%8E%A5%E5%8F%A3.html</url>
    <content type="text"><![CDATA[1. 概念接口是一个或多个方法签名的集合，只有方法声明，没有实现。 只要某个类型拥有该接口的所有方法签名，即算实现了该接口，无需显式声明了哪个接口，这称为 Structural Typing 。 接口也是一种类型，它是一种抽象类型，空接口 interface {} 类似于 NSObject 这样的万物之主，虽然 Go 中是没有 class 的概念，但 interface 实现了继承多态的效果。 2. 使用 样例1： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport ( "fmt")type USB interface &#123; Name() string Connecter // 嵌入&#125;type Connecter interface &#123; Connect()&#125;type PhoneConnecter struct &#123; name string&#125;func (pc PhoneConnecter) Name() string &#123; return pc.name&#125;func (pc PhoneConnecter) Connect() &#123; fmt.Println("Connect:", pc.name) // Disconnected: PhoneConnecter&#125;func Disconnect(usb interface&#123;&#125;) &#123; // ok pattern 进行类型判断 //if pc, ok := usb.(PhoneConnecter); ok &#123; // fmt.Println("Disconnected:", pc.name) // return //&#125; //fmt.Println("Disconnected.") // type switch 进行类型判断 switch v := usb.(type) &#123; case PhoneConnecter: fmt.Println("Disconnected:", v.name) // print "Connect: PhoneConnecter" default: fmt.Println("Unknown Device") &#125;&#125;func main() &#123; a := PhoneConnecter&#123;"PhoneConnecter"&#125; a.Connect() Disconnect(a)&#125; 样例2： 123456789101112131415161718192021222324252627282930313233package mainimport ( "fmt")type square struct &#123; r int &#125;type circle struct &#123; r int &#125;func (s square) area() int &#123; return s.r * s.r &#125;func (c circle) area() int &#123; return c.r * 3 &#125;func main() &#123; s := square&#123;2&#125; c := circle&#123;3&#125; a := [2]interface&#123;&#125;&#123;s, c&#125; fmt.Println(s, c, a) // print "&#123;2&#125; &#123;3&#125; [&#123;2&#125; &#123;3&#125;]" sum := 0 for _, t := range a &#123; switch v := t.(type) &#123; case square: sum += v.area() case circle: sum += v.area() &#125; &#125; fmt.Println(sum) // print "13"&#125;]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>interface</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 正则表达式的使用]]></title>
    <url>%2FSwift-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[Swift 中的正则表达式使用非常简单，直接上代码： 12345678910extension String &#123; /// 默认区分大小写，如需忽略大小写，options = .caseInsensitive func match(pattern: String, options: NSRegularExpression.Options = []) -&gt; [NSTextCheckingResult]? &#123; let regex = try? NSRegularExpression(pattern: pattern, options: options) guard regex != nil else &#123; return nil &#125; return regex!.matches(in: self, options: .reportProgress, range: NSRange(location: 0, length: self.count)) &#125;&#125; 以上是对 String 的扩展，使用如下： 123456789101112let input = "Hello, world, hello, everyone"if let results = input.match(pattern: "\\bhello\\b", options: .caseInsensitive) &#123; for res in results &#123; print(res.range) print("~~~~~~~~") &#125;&#125;// print &#123;0, 5&#125;// print ~~~~~~~~// print &#123;14, 5&#125;// print ~~~~~~~~ 关于正则表达式的使用，这里不再赘述，读者可以参考 正则表达式30分钟入门教程 NSRegularExpression.Options 的各个选项的作用如下： 12345678910111213NSRegularExpressionCaseInsensitive = 1 &lt;&lt; 0, // 不区分大小写字母模式NSRegularExpressionAllowCommentsAndWhitespace = 1 &lt;&lt; 1, // 忽略掉正则表达式中的空格和#号之后的字符NSRegularExpressionIgnoreMetacharacters = 1 &lt;&lt; 2, // 将正则表达式整体作为字符串处理NSRegularExpressionDotMatchesLineSeparators = 1 &lt;&lt; 3, // 允许.匹配任何字符，包括换行符NSRegularExpressionAnchorsMatchLines = 1 &lt;&lt; 4, // 允许^和$符号匹配行的开头和结尾NSRegularExpressionUseUnixLineSeparators = 1 &lt;&lt; 5, // 设置\n为唯一的行分隔符，否则所有的都有效。NSRegularExpressionUseUnicodeWordBoundaries = 1 &lt;&lt; 6 // /使用Unicode TR#29标准作为词的边界,否则所 NSRegularExpression.MatchingOptions 的各个选项的作用如下： 123456789NSMatchingReportProgress = 1 &lt;&lt; 0, // 找到最长的匹配字符串后调用block回调NSMatchingReportCompletion = 1 &lt;&lt; 1, // 找到任何一个匹配串后都回调一次blockNSMatchingAnchored = 1 &lt;&lt; 2, // 从匹配范围的开始进行极限匹配NSMatchingWithTransparentBounds = 1 &lt;&lt; 3, // 允许匹配的范围超出设置的范围NSMatchingWithoutAnchoringBounds = 1 &lt;&lt; 4 // 禁止^和$自动匹配行开始和结束]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>swift</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 运算符的重载和自定义]]></title>
    <url>%2FSwift-%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89.html</url>
    <content type="text"><![CDATA[1. 运算符的重载1.1 基本运算符的重载1234567891011func * (lhs: String, rhs: Int) -&gt; String &#123; var result = lhs for _ in 1..&lt;rhs &#123; result += lhs &#125; return result&#125;let t = "abc"print(t * 3)// print "abcabcabc" 如上所示，我们重载了运算符 * 。再看看另一个例子： 123struct Vector2D &#123; var x = 0.0, y = 0.0&#125; 我们定义了如上的结构体，如果想把两个 Vector2D 类型的实例相加，编译器是会报错的。如果我们重载操作符 + ，就可以实现相加： 1234567func + (lhs: Vector2D, rhs: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: lhs.x + lhs.x, y: rhs.y + rhs.y)&#125;let first = Vector2D(x: 1.0, y: 2.0)let second = Vector2D(x: 3.0, y: 4.0)print(first + second)// print "Vector2D(x: 4.0, y: 6.0)" 1.2 泛型运算符 1234567func * &lt;T&gt; (lhs: T, rhs: Int) -&gt; T &#123; var result = lhs for _ in 1..&lt;rhs &#123; result += lhs &#125; return result&#125; 按照常理，我们会将第一个例子做如上改写，但是编译器会提示 Binary operator ‘+=’ cannot be applied to two ‘T’ operands ，这是因为 T 类型并不能直接使用加法符合运算符，我们可以通过让 T 类型遵循实现了加法功能的协议来解决这个问题，改写后的代码如下： 1234567891011121314151617protocol Type &#123; static func + (lhs: Self, rhs: Self) -&gt; Self static func += (lhs: inout Self, rhs: Self)&#125;extension String: Type &#123;&#125;extension Int: Type &#123;&#125;extension CGFloat: Type &#123;&#125;func * &lt;T: Type&gt; (lhs: T, rhs: Int) -&gt; T &#123; var result = lhs for _ in 1..&lt;rhs &#123;// result = result + lhs result += lhs &#125; return result&#125; 2. 运算符的自定义先介绍 Swift 中的三个关键字： prefix：前缀运算符，比如 ++i 中的 ++ postfix：后缀运算符，比如 i++ 中的 ++ infix：中缀运算符，比如 a + b 中的 + 这里仅以 infix 为例示范其用法，现在我们自定义一个运算符 ** 和符合运算符 **= ，实现第一个例子的功能。 12345678910111213141516171819202122infix operator **func ** &lt;T: Type&gt; (lhs: T, rhs: Int) -&gt; T &#123; var result = lhs for _ in 1..&lt;rhs &#123; result += lhs &#125; return result&#125;infix operator **=func **= &lt;T: Type&gt; (lhs: inout T, rhs: Int) &#123; lhs = lhs ** rhs&#125;let t = "abc"let s = t ** 3print(s)// print "abcabcabc"var u = "abc"u **= 3print(u)// print "abcabcabc" 至此，运算符的重载和自定义的基本功能就介绍完毕了。当然，自定义运算符同样是可以定义优先级和结合性的，这里不做过多讲解，有兴趣的朋友可以自行查阅资料。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods 创建公有库命令]]></title>
    <url>%2FCocoaPods-%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E5%BA%93%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[1. 注册 CocoaPods 账号 通过终端运行一下命令注册账号： 1pod trunk register 邮箱地址 用户名 --verbose 然后去邮箱验证一下邮箱地址 注册成功后，可以通过 pod trunk me 查看账号信息和发布过的库 2. 公有库的内容构成2.1 共享的文件夹这里存放的是需要共享的内容，也就是别人通过 pod 安装得到的源码，.podspec 文件中的 source_files 指定的就是这个共享文件夹的路径 2.2 LICENSE 文件如果你的公有库是放在 GitHub 上托管，可以将工程上传以后，直接在网页给工程添加 LICENSE 文件，GitHub 会自动给出开源协议的可选项，一般选择 MIT 2.3 .podspec本库的描述文件，需要提交给 CocoaPods 可以通过一下命令创建 .podspec： 1pod spec create 库名 CocoaPods 默认会生成一个 .podspec 的模版文件，更改相应的信息即可，关于 .podspec 的各个参数解释，这里不再赘述，有需要的自行上网查找 3. 发布3.1 错误排查pod lib lint 命令可以验证本地的 .podspec 文件是否合法，如果与错误，会给出相应的提示，根据提示解决错误 3.2 将工程提交到 GitHub3.3 打上 tag12git tag 1.0.0git push --tags 注意： .podspec 中的 s.version 的值要和 tag 保持一致 3.4 发布pod trunk push 库名.podspec 发布成功后，pod search 库名 应该就可以搜到自己的库了 如果搜索不到，试试运行如下命令: 12pod setup rm ~/Library/Caches/CocoaPods/search_index.json 然后执行 pod search 库名 4. 更新更新代码，更改 .podspec 文件的 s.version ，打上 tag ，推送最新的代码到远端服务器，执行 pod lib lint 和 pod trunk push 库名.podspec]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017斯诺克英锦赛记忆]]></title>
    <url>%2F2017%E6%96%AF%E8%AF%BA%E5%85%8B%E8%8B%B1%E9%94%A6%E8%B5%9B%E8%AE%B0%E5%BF%86.html</url>
    <content type="text"><![CDATA[英锦赛，斯诺克历史上最悠久的赛事。40年前第一届英锦赛开打时，“75三杰”还在嗷嗷待哺。1993年，年仅17岁的火老师就摘得桂冠并成为历史上最年轻的排名赛冠军得主。这一纪录至今未被打破，刚刚过去的北爱公开赛，颜丙涛差点就刷新这项纪录，不过在接下来的两个多月里，他仍有希望打破这项纪录。 赛前回顾历届英锦赛得主，冠军数排名表如下： 球员 戴维斯 亨得利 奥沙利文 希金斯 蒙特乔 威廉姆斯 丁俊晖 罗伯逊 塞尔比 其他 次数 6 5 5 3 2 2 2 2 2 1 丁丁首日登场，5 - 1 领先对手，却被对手直落 5 局惨遭逆转。赛后，排名 120 开外的对手费尔南德斯说“我觉得我赢了他可以退役了…”。英锦赛本是丁丁的福赛，如今去上演了惊天大冷门，令人唏嘘。 R2 塞大师输给唐纳森意外出局，但唐纳森 R3 就被李行 6 - 1 血洗回家。希胖在 R3 又遭遇颜丙涛，不过这次希胖报仇成功，颜丙涛仍然有希望打破火神的最年轻排名赛冠军得主的记录。明明打的踉踉跄跄，希胖赛后还说自己状态很不错，希胖对自己要求咋这么低了？他是不是还没醒酒呢。希胖的糟糕状态延续至他和马克·金的比赛，一场业余比赛上演，最后希胖决胜局输掉。 萝卜本次比赛状态爆棚，不过在 R3 很遗憾地输掉了决胜局，被马克·乔伊斯截了胡。我们看看萝卜本次比赛的战绩： 三场比赛，网瘾少年轰出 8 杆破百，恐怖的进攻火力。我们仿佛看到了当年的金发少年，希望他能重回墨尔本机器的巅峰状态。 本次比赛，出现了一匹泰国黑马——宋沙瓦，他是本届英锦赛唯一对火箭构成威胁的人。宋沙瓦在 R3 阶段居然零封了霍师傅，霍师傅显然不太适应宋沙瓦的节奏，可谓乱拳打死霍师傅。 宋沙瓦在对阵火老师的时候，准度吓人，而火箭的状态并不好，我们一度以为宋沙瓦要继续他的黑马之路。可是，关键时刻，“幸运光环”触发，幸运女神出场改写了剧情。火老师最终在幸运女神的帮助下以迷之状态把宋沙瓦送回泰国，火老师证明了“越努力越幸运”？不过宋沙瓦虽败犹荣，他的进攻犀利，但是防守短板太明显了。靠准度是走不远的，围球有待加强。本届英锦赛，他双十合十的互动方式、特殊的架杆风采、蜜汁微笑和良好心态给观众留下了深刻的印象，他是风一样的男子。 比赛打到这个节骨眼上，火老师心里肯定开始想冠军了。果不其然，接下来对阵眼镜侠和马奎尔，火老师的状态恢复了不少，没有翻船，一路驰骋，杀进决赛。 另一边，墨菲状态很好，除了 R2 决胜局惊险过关，其他场次比赛都是大比分结束比赛。 决赛在周日晚上九点开打，火箭和墨胖都是进攻型选手，比赛肯定精彩纷呈。墨菲上来就一杆破百清台给了火老师一个下马威，我火神什么场面没见过，你个小胖子敢班门弄斧。火神立马拿下两局还以颜色，最终第一阶段上半场战成 2 - 2 打了个平手。火老师年龄大了，远台远逊于墨菲，却依然在下半场又连下两局，比分来到 4 - 2。墨菲被打的没脾气了，傲娇的头颅不再那么高昂，只能抿嘴和苦笑。墨菲心里一定在想：老子长台这么准，手感这么好，为啥还是干不过你丫？既生瑜，何生亮啊。。。Frame 7，赛场上的气氛出现了微妙的变化，墨菲的进攻有所收敛，不再冒进，明显有些怂了。墨菲抓住火老师的失误，拿下两局，第一阶段 4 - 4，两人回到同一起跑线，第二阶段11抢6。 S1 两人旗鼓相当，令人意外的是火老师的长台命中率居然这么高，比墨菲还要高。 S2 ，火老师放慢节奏，打的异常认真，将比分优势扩大至 9 - 5。其实墨菲今天的长台表现很好，总是长台先上手，但是没法完成超分，火老师就接管了台面。Last Frame，墨菲中远台低杆不进留下进攻机会。火箭未能一杆超分，一杆防守之后，墨菲尝试进攻未果，火箭在众望所归中赢下比赛。 火老师在决赛中轰出 3 杆破百，击球命中率高达 96%，长台命中率高达 80%，防守成功率高达 90%，这是一次完美的表演。 火箭已经获得了本赛季第三个排名赛冠军，这是它职业生涯第 31 座排名赛冠军。经此一役，火箭追平了戴维斯的英锦赛 6 冠记录，追平了亨得利的三大赛 18 冠记录，超越了亨得利在英锦赛的总破百杆数。不要忘了，今年的火箭已经 42 岁了，他仍然处于职业生涯的巅峰。 火老师决赛 3 杆破百视频：2017斯诺克英锦赛 决赛 奥沙利文【914】2017斯诺克英锦赛 决赛 奥沙利文【915】2017斯诺克英锦赛 决赛 奥沙利文【916】 最近突然想到一个问题：如果火老师退役了，我还会有那么大的看球的动力吗，我还会继续看斯诺克吗？一想到这里，心里就像打翻了五味瓶。不过我们所处的时代是幸运的，我们见证了斯诺克诞生以来的地表最强天才。世上岂有不老之身，不亡之人？很多年后，历史的长河里，他依然熠熠生辉。身体的死亡不是生命的终结，延续的精神才是生命的结晶。 赛后，火老师接受现场采访坦言现在和 24 年前没有什么不同，只是很努力享受斯诺克。他很难相信自己 42 岁了还在打球，他这年纪都能做很多小球员们的爸爸了 : ] 最后，送上火爸爸决赛视频，Enjoy it~ 2017斯诺克英锦赛 决赛 罗尼·奥沙利文 v 肖恩·墨菲]]></content>
      <categories>
        <category>snooker</category>
      </categories>
      <tags>
        <tag>snooker</tag>
        <tag>奥沙利文</tag>
        <tag>英锦赛</tag>
        <tag>墨菲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 编译器提示 TODO 和 FIXME]]></title>
    <url>%2FSwift-%E7%BC%96%E8%AF%91%E5%99%A8%E6%8F%90%E7%A4%BA-TODO-%E5%92%8C-FIXME.html</url>
    <content type="text"><![CDATA[Build Phases，点击 +，添加 New Run Script Phase，添加如下内容： 123TAGS="TODO:|FIXME:"echo "searching $&#123;SRCROOT&#125; for $&#123;TAGS&#125;"find "$&#123;SRCROOT&#125;" \( -name "*.swift" \) -print0 | xargs -0 egrep --with-filename --line-number --only-matching "($TAGS).*\$" | perl -p -e "s/($TAGS)/ warning: \$1/" 在代码处添加如下标记：12// TODO: something to do// FIXME: fix bug 编译器会自动给出相应的警告，并且可以快速定位到相应的代码处。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>swift</tag>
        <tag>TODO</tag>
        <tag>FIXME</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles 显示乱码问题解决方案]]></title>
    <url>%2FCharles-%E6%98%BE%E7%A4%BA%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
    <content type="text"><![CDATA[Charles 版本：4.2 安装 Mac 的 cer 证书后，点击 Charles 的 proxy - SSL Proxying Settings - SSL Proxying - Add，Host 填写 * ，Port 填写 443 安装手机上的 CA 证书后，点击 通用 - 关于本机 - 证书信任设置 ，信任对应的证书 Charles.app 右键显示包内容，打开 info.plist ，添加 vmoption 字段，设置对应的值为 -Dfile.encoding=UTF-8]]></content>
      <categories>
        <category>trick</category>
      </categories>
      <tags>
        <tag>trick</tag>
        <tag>charles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017斯诺克上海大师赛记忆]]></title>
    <url>%2F2017%E6%96%AF%E8%AF%BA%E5%85%8B%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%B8%88%E8%B5%9B%E8%AE%B0%E5%BF%86.html</url>
    <content type="text"><![CDATA[11月13 - 18日，几经折腾，第十一届上海大师赛如期举行。看国内举办的比赛不用熬夜了，这是件十分惬意的事情。 丁丁因为眼疾退出比赛，放弃了卫冕冠军的资格。墨菲、威尔逊、萝卜资格赛就输掉了，二师兄又被禁赛，这次 TOP16 的阵容不算完整。 首轮比赛，没有什么大的爆冷。有点可惜的是，瑞士小帅哥乌森巴赫首轮就遇上老辣的巫师，止步于此。 14号，卢卡对斯蒂文斯。比赛没有一点悬念，卢卡一顿乱拳 5 - 0 打死斯蒂文斯。真是拳怕少壮，马修老矣。卢卡好像丢了球杆和行李？应该是找艾伦借的墨绿色超大号背心，配上他的大光头，活脱脱一个和尚造型。这场球没什么看点，我也不会上传视频了。我想说的不是这场比赛，而是裁判。我们终于见到了久违的诸英重回赛场执裁，还是气质美女一枚 : ] 火老师15号早上九点半出场，现场观众爆棚啊。其中一局观众高呼 147，火箭也笑了，然而他还是选择了明智的粉球，如果 147 奖金累积到 5 万英镑，估计他会去打黑球~~ 最后单杆 144 清台，观众也是大饱眼福，这也是本次赛事截止当时的单杆最高分。 晚上的比赛，火老师对阵乔·佩里，没有什么意外，5 - 1 晋级16强。其他球台的比赛也没什么爆冷，至此，16强全部产生。令人欣喜的是，“75三杰”同时晋级！ 16进8的比赛，8张台同时开战，完全看不过来~~ 火箭和王牌君兵不血刃，都是 5 - 0 速胜晋级。看了下比赛记录，王牌君前三场球分别零封了伯顿、乌拉斯顿、马奎尔，实在恐怖，简直就是“零封之王”。现在特鲁姆普的球，确实比以前更成熟了，未来可期。巫师 5 - 2 战胜大博挺近8强，马叔 5 - 3 击败塞尔比晋级。“75三杰”职业生涯暮年之际一起挺进8强，实在难得！艾伦和利索夫斯基又是打决胜局，不过这次司机赢了。利索夫斯基，人如其名，打球十分利索的司机，如果他和小特在 1/4 决赛都晋级的话，这两个好基友就有望在半决赛搞基了。卢卡也是决胜局赢了多特晋级，傅家俊 2 - 5 不敌眼镜侠，梅希文也是 2 - 5 败给马福林。八强全部产生，中国军团全军覆没 : [ 晚上七点半的八进四比赛，一触即发。我用两个显示器同时看四个台的比赛，完全看不过来。。。Frame 1，火老师和总统君几乎同时翻进黑球赢得争黑~~总统上次在王中王被卢卡零封，这次又反打卢卡一个 5 - 0 速胜晋级，继续延续着此次大师赛的零封之路，简直不能太血腥。火箭和马叔两人状态一般，最后火箭 5 - 1 晋级四强继续迎战希胖，继续上演75双雄对决，而利索夫斯基和好基友总统君将在半决赛相爱相杀。 这应该是斯基第一次打进半决赛，开场两人状态都不太好。斯基 0 - 2 落后的情况下拿下一局，终结了总统的 22 连胜。斯基还是打的心急了些，不够冷静和放松，最终 3 - 6 输掉了比赛。反观现在的小特，打法和心态都比出道时沉稳太多。 75双雄对战，两人都不在状态，显然就是老年人斯诺克。两人打的踉踉跄跄，希胖越打越懵，火老师还算清醒，最后 6 - 2 结束比赛进入特奥会。这里说点题外话，看看下面这张图片，是历史破百数排行前十的选手的破百数与其年龄的关系图： 我第一次看到这张图的时候，有两个最直观的印象：一是小特的斜率是目前最高的，而看看他前几年的破百斜率不算高，这也正好印证了小特的球技从早年的粗犷狂傲逐渐过渡到现在的更加沉稳细腻。总统比塞尔比、萝卜、丁俊晖都要小，但是破百数却毫不逊色。第二个最直观的印象就是，我火一骑绝尘，大幅领跑破百排行榜。看看亨皇、希胖，斜率随着年龄增长都开始下降，而火老师似乎不太受年龄影响。我们看火老师现在的球，可谓已入化境，行云流水。除了随年龄增长，远台大不如前，但半台内仍然独步天下，无人能及。 上次冠中冠巫师被火老师打了个 6 - 0 ，这次又 2 - 6 出局。看着希胖臃肿的身躯和力不从心，实在有些心疼。同是“75三杰”，在职业生涯的末期，明显火老师更胜一筹。为什么？个人认为是因为火老师长期坚持运动和跑步，他的身材维持地还不错，体能和思敏程度明显是高于同时期的选手的。如果不是火箭的父亲坚持要他跑步，我们不会看到斯诺克之神的化身。我曾经有过一个假设：如果火老师没有遭遇家中变故、父亲入狱、酗酒戒酒等糟糕经历，他也许会比现在的成就更高？当然这只是假设，有时候人生太顺未必好过历经磨难。飓风希金斯是火老师的偶像，飓风没能避开糜烂的生活状态，而火老师没有沉沦，他做的比偶像更好，这是令人敬佩的地方。 “跑步是我的信仰体系，是我赖以保持内心平静的途径。跑步的过程身体是痛苦难耐的，但跑步又是让我达到精神高度的最佳途径。”这段话出自《奔跑吧，奥沙利文》，可见跑步在火箭的心中有多么地重要。跑步让他摆脱了瘾君子的生活，让他身体健康，思维敏捷。生命在于运动，如今我年纪渐长，越来越意识到运动的重要性。 球台上达到的成就，不仅仅取决于个人在球台上的练习，场外的因素也至关重要。比如场外的体能训练，它能让你在比赛中更坚挺更投入。又比如个人的性格成长和人生观念，对球路和球风也颇有影响。其实人生很多事情都是如此，一言以蔽之——“内在决定外在”。内外兼修，才能走得更高更远。 笔者笔拙，不知看官们能否理解我上面的题外话想要表达的意思~~ 扯远了，我们回到比赛，万众瞩目的特奥会如期而至，恰逢周六，现场座无虚席。赛前我查了一下两人的交手记录，都是10胜10负。决赛对战，总统4胜2负反而略占优势。 我们都以为比赛会很精彩，然而总是事与愿违，第一阶段总统手感奇差，一路输到 0 - 7 ，最后搬回两局。第二阶段已经无力回天了，最后比分定格在 3 - 10，用“血洗”来描述简直一点不为过。总统一路杀过来连赢22局，送了4个零蛋给对手，怎么决赛就萎了呢，我们无从得知，只有他自己最清楚了。不过这只是一场比赛罢了，不管输赢，都是历练。 恭喜火老师多得第30座排名赛冠军，不知道希胖看着会不会眼红再杀出一片天呢，希望如此，这是我们球迷的福音。 回顾了一下此次比赛，没有特别精彩的对决，最后附上决赛的视频以供观赏： 2017斯诺克上海大师赛决赛 罗尼·奥沙利文 v 贾德·特鲁姆普 S1 2017斯诺克上海大师赛决赛 罗尼·奥沙利文 v 贾德·特鲁姆普 S2]]></content>
      <categories>
        <category>snooker</category>
      </categories>
      <tags>
        <tag>snooker</tag>
        <tag>奥沙利文</tag>
        <tag>上海大师赛</tag>
        <tag>特鲁姆普</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift编程风格指南]]></title>
    <url>%2FSwift%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97.html</url>
    <content type="text"><![CDATA[1. 命名使用驼峰式命名法，类、结构体、枚举、协议的首字母应该大写，而方法、变量名首字母则小写。 123456private let maximumWidgetCount = 100class WidgetContainer &#123; var widgetButton: UIButton let widgetHeightPercentage = 0.85&#125; 1.1 枚举对于枚举值，应该使用首字母小写的驼峰命名法： 123456enum Shape &#123; case Rectangle case Square case Triangle case Circle&#125; 1.2 类名前缀(Class Prefix)Swift 类型自动为模块名设置了命名空间，所以没有必要为 Swift 的类型添加类似 KS 这样的前缀了。如果两个来自不同模块的命名冲突了了，你可以在它们前面添加模块名来避免冲突。 123import SomeModulelet myClass = MyModule.UsefulClass() 1.3 泛型泛型名应该有较好的阅读性，用首字母大写的驼峰式命名。当一个类型没有有意义的关系和角色，使用传统的 T、U、V 来替代。 123struct Stack&lt;Element&gt; &#123; ... &#125;func writeTo&lt;Target: OutputStream&gt;(inout target: Target)func max&lt;T: Comparable&gt;(x: T, _ y: T) -&gt; T 1.4 语言使用美式英语，更符合苹果的 API 标准。 2. 代码结构2.1 代码分块使用// MARK: -对代码进行分块组织，代码的组织顺序从整体上尽量符合我们的认知顺序。 2.2 无用代码对于无用的代码，都应该被删掉。 2.3 最小引用只import你需要的模块。比如，如果引用Foundation以及足够，就不要再引用UIKit了。 3. 类和结构体3.1 选择哪个？结构体是值类型，类是引用类型。 按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体： 该数据结构的主要目的是用来封装少量相关简单数据值。 有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。 该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。 该数据结构不需要去继承另一个既有类型的属性或者行为。 3.2 Self 的使用为了保持简洁，避免使用 self 关键词，Swift 不需要使用 self 来访问对象属性和调用对象方法。 在以下情况中需要使用self： 在构造器中，为了区分传入的参数和属性 在闭包中访问属性 123456789101112class BoardLocation &#123; let row: Int, column: Int init(row: Int, column: Int) &#123; self.row = row self.column = column let closure = &#123; println(self.row) &#125; &#125;&#125; 3.3 计算属性如果一个计算属性是只读的，忽略 get 语句。只有在需要定义 set 语句的时候，才提供 get 语句。123var diameter: Double &#123; return radius * 2&#125; 3.4 Final如果类不会被继承，那么用关键词 final 标记。 123456final class Box&lt;T&gt; &#123; let value: T init(_ value: T) &#123; self.value = value &#125;&#125; 4. 协议遵守当我们对一个类添加协议时，推荐使用一个单独的类扩展来实现协议的方法。这可以保持协议相关的方法聚合在一起，同时也可以简单的标识出一个协议对应类中需要实现哪些对应的方法。 推荐做法：12345678910111213class MyViewcontroller: UIViewController &#123; // class stuff here&#125;// MARK: - UITableViewDataSourceextension MyViewcontroller: UITableViewDataSource &#123; // table view data source methods&#125;// MARK: - UIScrollViewDelegateextension MyViewcontroller: UIScrollViewDelegate &#123; // scroll view delegate methods&#125; 不推荐做法：123class MyViewcontroller: UIViewController, UITableViewDataSource, UIScrollViewDelegate &#123; // all methods&#125; 5. 函数声明保证短的函数定义在同一行中，并且包含左大括号： 123func reticulateSplines(spline: [Double]) -&gt; Bool &#123; // reticulate code goes here&#125; 在一个长的函数定义时，在适当的地方进行换行，同时在下一行中添加一个额外的缩进： 1234func reticulateSplines(spline: [Double], adjustmentFactor: Double, translateConstant: Int, comment: String) -&gt; Bool &#123; // reticulate code goes here&#125; 6. 闭包表达式详细参考：Swift 中的闭包 7. 类型尽可能使用 Swift 原生类型。 7.1 常量常量定义使用 let 关键字，变量定义使用 var 关键字，如果变量的值不需要改变，请尽量使用 let 关键字。提示：一个好的技巧是，使用 let 定义任何东西，只有在编译器告诉我们值需要改变的时候才改成 var 定义。 7.2 可选类型当一个变量或函数返回值可以为 nil 时，用 ? 将其声明为可选类型。 当确定变量在使用前被初始化，使用 ! 来解包。 必要时，使用可选值链： 1self.textContainer?.textLabel?.setNeedsDisplay() 对于需要将可选值解包，并多出使用的情况，使用可选值绑定： 123if let textContainer = self.textContainer &#123; // do many things with textContainer&#125; 当我们命名一个可选变量和属性时，避免使用诸如 optionalString 和 maybeView 这样的命名，因为可选值的表达已经在类型定义中了。 在可选值绑定中，直接映射原始的命名比使用诸如 unwrappedView 和 actualLabel 要好。 推荐做法： 1234567var subview: UIView?var volume: Double?// later on...if let subview = subview, volume = volume &#123; // do something with unwrapped subview and volume&#125; 7.3 语法糖推荐使用简短的类型声明。 推荐做法： 123var deviceModels: [String]var employees: [Int: String]var faxNumber: Int? 不推荐做法： 123var deviceModels: Array&lt;String&gt;var employees: Dictionary&lt;Int, String&gt;var faxNumber: Optional&lt;Int&gt; 8. 控制流使用循环时，推荐用 for-in 表达式，而不是 for-condition-increment 表达式。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>swift</tag>
        <tag>编程风格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 中的一些关键字]]></title>
    <url>%2FSwift-%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content type="text"><![CDATA[open：可以在任何地方访问、继承和重写 public：可以在任何地方被访问，在其他模块不能被继承和重写 internal：默认访问级别，在整个模块内都可以被访问 fileprivate：可以在同一个文件内被访问、继承和重写 private：只能在本类访问和使用，不包括扩展类 fallthrough ：Swift 中的 switch 语句可以省略 break，满足条件直接跳出循环。fallthrough 则具有贯穿作用，会继续执行后续的 case，直到碰到 break 或 default 才跳出循环。 123456789switch integerToDescribe &#123; case 1, 3, 5, 7, 11, 13, 17, 19: description += " a prime number, and also"; fallthrough // 执行到此并不跳出循环,而是继续执行case5case 5: description += " an integer" // 执行到这一步,跳出循环default : description += " finished" &#125; where：用于条件判断 12345678let yetAnotherPoint = (1, -1) switch yetAnotherPoint &#123; case let (x, y) where x == y: println("(\\(x), \\(y)) is on the line x == y") case let (x, y) where x == -y: println("(\\(x), \\(y)) is on the line x == -y") case let (x, y): println("(\\(x), \\(y)) is just some arbitrary point") inout：将值类型参数以引用方式传递 123456var x = 10func add(x: inout Int, y: Int) &#123; x += y&#125;add(x: &amp;x, y: 5)print(x) // x = 15 is &amp; as：is 用于类型判断，as 用于强制转换 12345678for view : AnyObject in self.view.subviews &#123; if view is UIButton &#123; let btn = view as UIButton; println(btn) &#125; &#125; as 使用场合： 向上转型： 1234class Animal &#123;&#125;class Cat: Animal &#123;&#125;let cat = Cat()let animal = cat as Animal 数值类型转换： 1234let num1 = 42 as CGFloatlet num2 = 42 as Intlet num3 = 42.5 as Intlet num4 = (42 / 2) as Double switch 语句 1234567switch animal &#123; case let cat as Cat: print("如果是Cat类型对象，则做相应处理") case let dog as Dog: print("如果是Dog类型对象，则做相应处理") default: break&#125; as! 用于强制转换，转换失败会导致程序崩溃，而 as? 转换失败时会返回一个 nil 对象。 guard：与 if 相反，当不满足条件时执行后面的语句。 123456789func test(input: Int?) &#123; guard let _ = input else &#123; print("Input cannot be nil") return &#125;&#125;test(input: nil)// print "Input cannot be nil" defer：该关键字包裹的一段代码会延迟执行，当前作用域结束的时候会被调用。当同一个作用域指定多个 defer 代码块，在当前作用域结束时，先定义的后执行，后定义的先执行。 static：和 class 关键词一样，都用来生成类方法，不同的是，class 修饰的方法可以被重写，而 static 不行。 mutating ：当需要在方法中修改 struct、enum 中的成员值时，用 mutating 修饰对应的方法。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIScrollView+AutoLayout]]></title>
    <url>%2FUIScrollView-AutoLayout.html</url>
    <content type="text"><![CDATA[网上有很多关于 UIScrollView+AutoLayout 的教程，这里不再赘述。 记录关键的两点： 1、在约束嵌套在 UIScrollView 中的 view 时，如图所示，除了添加它和父视图（UIScrollView）的约束关系外，还要添加它和 UIScrollView 的父视图（图中最顶层的view）的约束关系（Equal width , Equal height）。 2、一定要设置 Priority ，如果要竖直滚动视图，就设置如图示的 Equal height 的 Priority，以此类推。 Sample code：demp/UIScrollView+AutoLayout]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>UIScrollView</tag>
        <tag>AutoLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的闭包]]></title>
    <url>%2FSwift%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85.html</url>
    <content type="text"><![CDATA[1. 闭包表达式语法123&#123; (parameters) -&gt; returnType in statements&#125; 下面是利用闭包对数组进行反向排序的一个例子： 123456let names = ["Chris", "Alex", "Ewa", "Barry", "David"]let reservedNames = names.sorted &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2&#125;print(reservedNames)// print "["Ewa", "David", "Chris", "Barry", "Alex"]" 2. 根据上下文推断类型上文中的参数类型和返回类型都可以被正确推断，因此可以简写为如下形式： 1let reservedNames = names.sorted &#123; s1, s2 in return s1 &gt; s2 &#125; 3. 单表达式闭包返回单行表达式闭包可以省略关键字 return ，上例可以进一步简写为： 1let reservedNames = names.sorted &#123; s1, s2 in s1 &gt; s2 &#125; 4. 参数名称缩写Swift 自动为内联闭包提供参数名称缩写功能，可以直接通过 $0， $1， $2 来顺序调用闭包的参数，以此类推。 如果使用缩写的参数名称，可以在闭包定义中省略参数列表，Swift 会自动推断参数类型。in 关键字也可以被省略，因此上例的极简写法如下： 1let reservedNames = names.sorted &#123; $0 &gt; $1 &#125; 5. 尾随闭包如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性。 尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个函数调用。在使用尾随闭包时，不用写出它的参数标签。 1let reservedNames = names.sorted() &#123; $0 &gt; $1 &#125; 当闭包表达式是函数或方法的唯一参数时，可以省略 () ： 1let reservedNames = names.sorted &#123; $0 &gt; $1 &#125; 6. 值捕获12345678910111213func makeIncremeter(forIncrement amount: Int) -&gt; () -&gt; Int &#123; var runningTotal = 0 func incremeter() -&gt; Int &#123; runningTotal += amount return runningTotal &#125; return incremeter&#125;let incrementByTen = makeIncremeter(forIncrement: 10)incrementByTen() // return 10incrementByTen() // return 20incrementByTen() // return 30 incrementer() 是一个嵌套函数，它从外围函数捕获了 runningTotal 和 amount 变量的引用。捕获引用保证了 runningTotal 和 amount 变量在调用完 makeIncrementer 后不会消失，并且保证了在下一次执行 incrementer函数时， runnningTotal 依旧存在。 如果你创建了另一个 incrementer ，它会有属于自己的引用，指向一个全新、独立的 runningTotal 变量： 123let incrementByFive = makeIncremeter(forIncrement: 5)incrementByFive() // return 5incrementByFive() // return 10 再看看下面的代码： 12let alsoIncrementerByTen = incrementByTenalsoIncrementerByTen() // return 40 这说明 alsoIncrementerByTen 和 incrementerByTen 指向的是同一个闭包，说明闭包时引用类型。 7. 逃逸闭包当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸，我们在参数名之前标注 @escaping 来表明这个闭包时允许“逃逸”出这个函数的。 一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。下面这个例子中的闭包会在函数返回之后才被调用： 1234var completionHandles: [() -&gt; Void] = []func someFunctionWithEscapinClosure(completionHandler: @escaping () -&gt; Void) &#123; completionHandles.append(completionHandler)&#125; 将一个闭包标记为 escaping 意味着你必须在闭包中显式地引用 self 。而非逃逸闭包，可以隐式地引用 self 。 12345678910111213141516171819202122func someFunctionWithNonescapingClosure(closure: () -&gt; Void) &#123; closure()&#125;class SomeClass &#123; var x = 10 func doSomething() &#123; someFunctionWithEscapinClosure &#123; self.x = 100 &#125; someFunctionWithNonescapingClosure &#123; x = 200 &#125; &#125;&#125;let instance = SomeClass()instance.doSomething()print(instance.x) // print "200"completionHandles.first?()print(instance.x) // print "100" 8. 自动闭包自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。它不接受任何参数，当它被调用时，会返回被包装在其中的表达式的值。自动闭包只有被调用的时候，代码才会延迟执行。 12345678var arr = [1, 2, 3, 4, 5]print(arr.count) // print "5"let cl = &#123; arr.remove(at: 0) &#125;print(arr.count) // print "5" , 说明闭包并没有执行print("Now remove \(cl())") // print "Now remove 1", 此时调用了自动闭包print(arr.count) // print "4" 注：cl 的类型不是 Int ， 而是 () -&gt; Int ，一个没有参数且返回值为 Int 的函数。 将闭包作为参数传递给函数时，同样能获得延时求值行为。 12345678func cl(element removeElement: () -&gt; Int) &#123; print("Now remove \(removeElement())")&#125;cl &#123; () -&gt; Int in arr.remove(at: 0)&#125;// print "Now remove 2" 上面的 cl 函数接受一个返回移除元素的显式的闭包。下面的例子完成了相同的操作，不过它并没有接受一个显式的闭包，而是通过将参数标记为 @autoclosure 来接收一个自动闭包。现在你可以将该函数当做接受 Int 类型参数（而非闭包）的函数来调用，removeElement 参数将自动转化为一个闭包。 123456func cl2(remove removeElement: @autoclosure () -&gt; Int) &#123; print("Now remove \(removeElement())")&#125;cl2(remove: arr.remove(at: 0))// print "Now remove 3" 如果你想让一个自动闭包可以“逃逸”， 则应该同时使用 @autoclosure 和 escaping 关键字。]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS疑难杂症]]></title>
    <url>%2FiOS%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87.html</url>
    <content type="text"><![CDATA[1. The file “Info.plist” couldn’t be opened because there is no such file.原因： Info.plist 文件找不到了，可能是被删除了或是被移动了。解决方法：按照下面的顺序找到 info.plist File ，修改成 info.plist 的实际路径即可。1targets --&gt; Build Settings --&gt;搜索 Info.plist --&gt; Packaging -&gt; info.plist File 2. 只要有改动 Xcode 不停地 building选择任意一个 Storyboard ，Editor -&gt; Automatically Refresh Views， 关闭这个选项即可。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>疑难杂症</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的泛型]]></title>
    <url>%2FSwift%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B.html</url>
    <content type="text"><![CDATA[1. 泛型函数123456789101112131415func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123; let t = a a = b b = t&#125;var someInt = 3var anotherInt = 7swapTwoValues(&amp;someInt, &amp;anotherInt)print("\(someInt), \(anotherInt)")// print "7, 3"var someString = "hello"var anotherString = "world"swapTwoValues(&amp;someString, &amp;anotherString) T 是占位类型名，用来代替实际类型名。 2. 泛型类型下面的例子定义了一个泛型的栈（stack）结构体，从而能够处理任意类型的值。 12345678910111213141516struct Stack&lt;Element&gt; &#123; var items = [Element]() mutating func push(item: Element) &#123; items.append(item) &#125; mutating func pop() -&gt; Element &#123; return items.removeLast() &#125;&#125;var stackOfStrings = Stack&lt;String&gt;()stackOfStrings.push(item: "A")stackOfStrings.push(item: "B")stackOfStrings.push(item: "C")let fromTheTop = stackOfStrings.pop() 3. 扩展一个泛型类型1234567extension Stack &#123; var topItem: Element? &#123; return items.isEmpty ? nil : items[items.count - 1] &#125;&#125;stackOfStrings.topItem // "B" 4. 类型约束12345678910111213func findIndex(ofString valueToFind: String, in array: [String]) -&gt; Int? &#123; for(index, value) in array.enumerated() &#123; if value == valueToFind &#123; return index &#125; &#125; return nil&#125;let strings = ["A", "B", "C"]if let foundIndex = findIndex(ofString: "B", in: strings) &#123; print("\(foundIndex)")&#125;// print "1" 上面的例子展示了在一个字符串数组中找到对应字符串的索引，但是并不适用于包含其他类型的元素的数组。 12345678func findIndex&lt;T: Equatable&gt;(array: [T], _ valueToFind: T) -&gt; Int? &#123; for (index, value) in array.enumerated() &#123; if value == valueToFind &#123; return index &#125; &#125; return nil&#125; Equatable 给占位类型 T 添加了类型约束，意味着上面的函数只能包含 Equatable 类型的元素。不是所有的 Swift 类型都可以用 == 进行比较，除非该类型遵循了 Equatable 协议。 5. 关联类型关联类型为协议中的某个类型提供了一个占位名，其代表的实际类型在协议被采纳时才会被指定，用关键字 associatedtype 关键字来指定关联类型。 123456protocol Container &#123; associatedtype ItemType mutating func append(item: ItemType) var count: Int &#123; get &#125; subscript(i: Int) -&gt; ItemType &#123; get &#125;&#125; 我们还可以通过扩展一个存在的类型来指定关联类型，比如： 1extension Array: Container &#123;&#125; 6. 泛型Where语句where 字据可以给一个关联类型添加类型约束，语法如下： 12func genericFunc&lt;S&gt;(p: S) -&gt; returnType where #判断语句# &#123;&#125;]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的协议]]></title>
    <url>%2FSwift%E4%B8%AD%E7%9A%84%E5%8D%8F%E8%AE%AE.html</url>
    <content type="text"><![CDATA[1. 协议语法123protocol SomeProtocol &#123; // code&#125; 要让自定义类型遵循某个协议，在类型名称后加上协议名称即可，中间以冒号（:）分隔，遵循多个协议时，各协议之间用逗号（、）分隔： 123struct SomeStruct: FirstProtocol, AnotherProtocol &#123; // code&#125; 拥有父类的类在遵循协议时，应该将父类名放在协议名之前，以逗号分隔： 123class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol &#123; // code&#125; 2. 属性要求1234protocol SomeProtocol &#123; var mustBeSettable: Int &#123; get set &#125; //可读可写的变量属性 var doesNotNeedToBeSettable: Int &#123; get &#125; //可读变量属性&#125; 123protocol AnotherProtocol &#123; static var someTypeProperty: Int &#123; get set &#125; //类型属性，还可以用class关键字声明&#125; 如下所示，这是一个只含有一个实例属性要求的协议。这个协议表示，任何遵循FullyNamed的类型，都必须有一个可读的String类型的实力属性fullName。 123protocol FullyNamed &#123; var fullName: String &#123; get &#125;&#125; 下面是一个遵循FullyNamed协议的简单结构体： 12345struct Person: FullyNamed &#123; var fullName: String&#125;let john = Person(fullName: "John Higgins") 下面是一个更为复杂的类，它适配并遵循了FullyNamed协议： 123456789101112131415class StarShip: FullyNamed &#123; var prefix: String? var name: String init(name: String, prefix: String? = nil) &#123; self.name = name self.prefix = prefix &#125; var fullName: String &#123; return (prefix != nil ? prefix! + " " : "") + name &#125;&#125;var ncc1701 = StarShip(name: "Enterprise", prefix: "USS")print(ncc1701.fullName)// print "USS Enterprise" 3. 方法要求123protocol SomeProtocol &#123; static func someTypeMethod() // 类方法还可以用class关键字修饰&#125; 下面的例子定义了一个只含有一个实例方法的协议: 123protocol RandomNumberGenerator &#123; func random() -&gt; Double&#125; 下面的类实现了一个叫做线性同余生成器的伪随机数算法： 12345678910class LinearCongruentialGenerator: RandomNumberGenerator &#123; var lastRandom = 42.0 let m = 139968.0 let a = 3877.0 let c = 29573.0 func random() -&gt; Double &#123; lastRandom = (lastRandom * a + c).truncatingRemainder(dividingBy: m) return lastRandom / m &#125;&#125; 4. Mutating方法要求实现协议中的mutating方法时，若是类类型，则不用写mutating关键字，而对于结构体和枚举，则必须写mutating关键字。 123456789101112131415161718protocol Togglable &#123; mutating func toggle()&#125;enum OnOffSwitch: Togglable &#123; case Off, On mutating func toggle() &#123; switch self &#123; case .Off: self = .On case .On: self = .Off &#125; &#125;&#125;var lightSwitch = OnOffSwitch.OfflightSwitch.toggle() // On 5. 构造器要求123456789protocol SomeProtocol &#123; init(someParameter: Int)&#125;class SomeClass: SomeProtocol &#123; required init(someParameter: Int) &#123; // 构造器实现部分 &#125;&#125; 如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注required和override修饰符： 1234567891011class SomeSuperClass &#123; init() &#123; // 构造器实现部分 &#125;&#125;class SomeSubClass: SomeSuperClass, SomeProtocol &#123; required override init() &#123; // 构造器实现部分 &#125;&#125; 6. 协议作为类型1234567891011class Dice &#123; let sides: Int let generator: RandomNumberGenerator init(sides: Int, generotor: RandomNumberGenerator) &#123; self.sides = sides self.generator = generator &#125; func roll() -&gt; Int &#123; return Int(generator.random() * Double(sides)) + 1 &#125;&#125; generator属性的类型为RandomNumberGenerator，因此任何遵循了RandomNumberGenerator协议的类型的实例都可以赋值给generator，除此之外并无其他要求。 7. 委托（代理）模式123456789101112131415161718192021222324protocol SayHelloDelegate &#123; func sayHello(name: String)&#125;class ClassA &#123; var delegate: SayHelloDelegate? var name = "Lucy" func play() &#123; delegate?.sayHello(name: name) &#125;&#125;class ClassB: SayHelloDelegate &#123; var name = "Lily" func sayHello(name: String) &#123; print("\(name) 请 \(self.name) 帮她 say Hello") &#125;&#125;var ca = ClassA()var cb = ClassB()ca.delegate = cbca.play()// print "Lucy 请 Lily 帮她 say Hello" 8. 协议中添加扩展123456789101112131415161718192021222324252627282930protocol Score &#123; var math: Int &#123; get set &#125; var english: Int &#123; get set &#125; func mathPercent() -&gt; Double&#125;struct Puple: Score &#123; var math: Int var english: Int func mathPercent() -&gt; Double &#123; return Double(math) / Double(math + english) &#125;&#125;let p1 = Puple(math: 90, english: 80)p1.mathPercent() // 0.529extension Score &#123; func mathPercent() -&gt; Double &#123; return Double(math) / Double(math + english) &#125;&#125;struct CollageStudent: Score &#123; var math: Int var english: Int&#125;let c1 = CollageStudent(math: 80, english: 80)c1.mathPercent() // 0.5 如此，我们可以不实现mathPercent方法也能计算出数学所占分数的比例。]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人与人之间的关系]]></title>
    <url>%2F%E4%BA%BA%E4%B8%8E%E4%BA%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.html</url>
    <content type="text"><![CDATA[微博上刷到这几张图片，对我的触动很大，激发出我很强的认同感。这可能是我整个荒废的十一假期得到的唯一且最大的思想收获了：） 随着年纪愈长，我的思想观念也开始趋于清晰和稳定。李安对人际关系的理解，远远超出了当代人的水平，也许人类还需要几百年的发展才能达到他所描述的人际关系。 回望过去的自己，真的是幼稚的可怕。现在的我，仍然需要被雕刻。 我们每个人都是独立的个体，不可能有完全一样的价值观。能气味相投的人，价值观上必然存在相互之间的认同感。面对形形色色的人，我不喜欢用“善变”来处理和他们的关系。我努力寻找自我，一直希望找到一种普适的方法。前段时间，我希望自己做个“真实而温暖”的人。这个定义应该需要优化一下，如果我喜欢作恶，也许也是真实的一面，但那样不好，或许善良比真实的涵义更美好，它应该是涵盖了真实的全部成分。所以，我需要努力去做一个“善良而温暖”的人。 受李安的启发，最后结语，我觉得人和人之间比较理想的状态是：爱和尊重。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>李安</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的扩展]]></title>
    <url>%2FSwift%E4%B8%AD%E7%9A%84%E6%89%A9%E5%B1%95.html</url>
    <content type="text"><![CDATA[扩展就是为一个已有的类、结构体、枚举类型或者协议类型添加新功能。 1. 扩展语法123extension SomeType &#123; // code&#125; 可以通过扩展来扩展一个已有类型，使其采纳一个或多个协议： 123extension SomeType: SomeProtocol, AnotherProtocol &#123; // protocol code&#125; 2. 计算型属性1234567891011extension Double &#123; var km: Double &#123; return self * 1000 &#125; var m: Double &#123; return self &#125; var cm: Double &#123; return self / 100.0 &#125; var mm: Double &#123; return self / 1000.0 &#125; var ft: Double &#123; return self / 3.28084 &#125;&#125;let oneInch = 25.4.mmprint("One inch is \(oneInch) meters")// print "One inch is 0.0254 meters" 注意：扩展可以添加新的计算属性，但是不可以添加存储属性，也不可以为已有属性添加属性观察器。 3. 构造器1234567891011121314151617181920struct Size &#123; var width = 0.0, height = 0.0&#125;struct Point &#123; var x = 0.0, y = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size()&#125;extension Rect &#123; init(center: Point, size: Size) &#123; let originX = center.x - (size.width / 2) let originY = center.y - (size.height / 2) self.init(origin: Point(x: originX, y: originY), size: size) &#125;&#125; 这个新的构造器首先根据提供的center和size的值计算一个合适的原点。然后调用该结构体的逐一成员构造器init(origin:size:)，该构造器将新的原点和大小的值保存到了相应的属性中： 1let centerRect = Rect(center: Point(x: 4.0, y: 4.0), size: Size(width: 3.0, height: 3.0)) 注意：如果你使用扩展提供了一个新的构造器，你依旧有责任确保构造过程能够让实例完全初始化。 4. 方法123456789101112131415extension Int &#123; func repetitions(task:() -&gt; Void) &#123; for _ in 0..&lt;self &#123; task() &#125; &#125;&#125;3.repetitions &#123; print("Hello")&#125;// print "Hello"// print "Hello"// print "Hello" 4.1 可变实例方法12345678910extension Int &#123; mutating func square() &#123; self = self * self &#125;&#125;var someInt = 3someInt.square()print(someInt)// print "9" 5. 下标12345678910111213141516extension Int &#123; subscript(digitIndex: Int) -&gt; Int &#123; var decimalBase = 1 for _ in 0..&lt;digitIndex &#123; decimalBase *= 10 &#125; return (self / decimalBase) % 10 &#125;&#125;print(9876543210[2])// print "2"print(9876543210[3])// print "3"print(9876543210[15])// print "0" 6. 嵌套类型扩展可以为已有的类、结构体和枚举添加新的嵌套类型。 123456789101112131415extension Int &#123; enum Kind &#123; case Negative, Zero, Positive &#125; var kind: Kind &#123; switch self &#123; case 0: return .Zero case let x where x &gt; 0: return .Positive default: return .Negative &#125; &#125;&#125; 12345678910111213141516func printIntegerKinds(_ numbers: [Int]) &#123; for number in numbers &#123; switch number.kind &#123; case .Negative: print("-", terminator:"") case .Zero: print("0", terminator:"") case .Positive: print("+", terminator:"") &#125; &#125; print("")&#125;printIntegerKinds([3, 19, -27, 0, -6, 0, 7])// print "++-0-0+"]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的析构过程]]></title>
    <url>%2FSwift%E4%B8%AD%E7%9A%84%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B.html</url>
    <content type="text"><![CDATA[析构器只适用于类型，当一个类的实例被释放之前，析构器会被立即调用。析构器用关键字deinit来标示，类似于构造器要用init标示。 1. 析构过程原理在类的定义中，每个类最多只有一个析构器，而且析构器不带任何参数。 123deinit &#123; // 执行析构过程&#125; 析构器是在实例释放发生前被自动调用，你不能主动调用析构器。 因为直到实例的析构器被调用后，实例才会被释放，所以析构器可以访问实例的所有属性。 2. 析构器实践123456789101112131415161718192021222324252627282930class Bank &#123; static var coinsInBank = 10000 static func distribute(coins numberOfCoinsRequested: Int) -&gt; Int &#123; let numberOfCoinsToVend = min(numberOfCoinsRequested, coinsInBank) coinsInBank -= numberOfCoinsToVend return numberOfCoinsToVend &#125; static func receive(coins: Int) &#123; coinsInBank += coins &#125;&#125;class Player &#123; var coinsInPurse: Int init(coins: Int) &#123; coinsInPurse = Bank.distribute(coins: coins) &#125; func win(coins: Int) &#123; coinsInPurse += Bank.distribute(coins: coins) &#125; deinit &#123; Bank.receive(coins: coinsInPurse) &#125;&#125;var playerOne: Player? = Player(coins: 100)playerOne!.win(coins: 2000)playerOne = nilprint("The bank now has \(Bank.coinsInBank) coins")// The bank now has 10000 coins 在这里，析构器的作用只是将玩家的所有硬币都返给Bank对象。 playOne = nil意味着没有Player实例，因此该实例会被释放，以便回收内存。在这之前，该实例的析构器被自动调用，玩家的硬币被返给银行。]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>析构过程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中构造过程]]></title>
    <url>%2FSwift%E4%B8%AD%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B.html</url>
    <content type="text"><![CDATA[1. 存储属性的初始赋值1.1 构造器12345678910struct Fahrenheit &#123; var temperature: Double init() &#123; temperature = 32.0 &#125;&#125;var f = Fahrenheit()print("The default temperature is \(f.temperature)")// print "The default temperature is 32.0" 上面这个结构体定义了一个不带参数的构造器init，并将存储属性temperature值初始化为32.0。 1.2 默认属性值123struct Fahrenheit &#123; var temperature = 32.0&#125; 使用默认值能让你的构造器更简洁、更清晰，且能通过默认值自动推导出属性的类型。 2 自定义构造过程2.1 构造参数123456789struct Celsius &#123; var temperatureInCelsius: Double init(fromFahrenheit fahrenheit: Double) &#123; temperatureInCelsius = (fahrenheit - 32.0) / 1.8 &#125; init(fromKelvin kelvin: Double) &#123; temperatureInCelsius = kelvin - 273.15 &#125;&#125; 第一个构造器拥有一个构造参数，外部参数名为fromFahrenheit，内部参数名为fahrenheit。 2.2 不带外部名的构造器参数我们可以用_来代替外部参数名。 2.3 可选属性类型12345678910class SurveyQuestion &#123; var text: String var response: String? init(text: String) &#123; self.text = text &#125; func ask() &#123; print(text) &#125;&#125; 3. 默认构造器1234567class ShoppingListItem &#123; var name: String? var quantity = 1 var purchased = false&#125;var item = ShoppingListItem() 尽管代码中没有显式地为name属性设置默认值，但由于name是可选字符串类型，它将默认值设置为nil。 3.1 结构体的逐一成员构造器12345struct Size &#123; var width = 0.0, height = 0.0&#125;let twoByTwo = Size(width: 2.0, height: 2.0) 4. 值类型的构造器代理构造器可以通过调用其它构造器来完成实例部分构造过程。这一过程成为构造器代理，它能减少多个构造器间的代码重复。 如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器(如果是结构体，还将无法访问逐 一成员构造器)。这种限制可以防止你为值类型增加了一个额外的且十分复杂的构造器之后,仍然有人错误的使用 自动生成的构造器。 假如你希望默认构造器、逐一成员构造器以及你自己的自定义构造器都能用来创建实例，可以将自定义的构造器 写到扩展(extension)中，而不是写在值类型的原始定义中。 123456789101112131415161718192021222324252627struct Size &#123; var width = 0.0, height = 0.0&#125;struct Point &#123; var x = 0.0, y = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size() init() &#123; &#125; init(origin: Point, size: Size) &#123; self.origin = origin self.size = size &#125; init(center: Point, size: Size) &#123; let originX = center.x - (size.width / 2) let originY = center.y - (size.height / 2) self.init(origin: Point(x: originX, y: originY), size: size) &#125;&#125; 5. 类的继承和构造过程类里面的所有存储型属性——包括所有继承自父类的属性——都必须在构造过程中设置初始值。 Swift 为类类型提供了两种构造器来确保实例中所有存储型属性都能获得初始值，它们分别是指定构造器和便利 构造器。 5.1 指定构造器和便利构造器的语法指定构造器：123init(parameters) &#123; statements&#125; 便利构造器：123convenience init(parameters) &#123; statements&#125; 5.1 类的构造器代理规则规则 1指定构造器必须调用其直接父类的的指定构造器。规则 2便利构造器必须调用同类中定义的其它构造器。规则 3便利构造器必须最终导致一个指定构造器被调用。 一个更方便的记忆方法是：指定构造器必须总是向上代理，便利构造器必须总是横向代理。 5.2 构造器的继承和重写跟 Objective-C 中的子类不同，Swift 中的子类默认情况下不会继承父类的构造器。Swift 的这种机制可以防止 一个父类的简单构造器被一个更精细的子类继承，并被错误地用来创建子类的实例。 12345678910111213class Vehicle &#123; var numberOfWheels = 0 var description: String &#123; return "\(numberOfWheels) wheel(s)" &#125;&#125;class Bicycle: Vehicle &#123; override init() &#123; super.init() numberOfWheels = 2 &#125;&#125; 子类Bicycle定义了一个指定构造器init()。调用super.init()方法，可以确保Bicycle在修改属性之前，它所继承的属性numberOfWheels能被Vehicle类初始化。 注意子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性。 5.3 构造器的自动继承假设你为子类中引入的所有新属性都提供了默认值，以下 2 个规则适用: 规则 1如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。 规则 2如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将 自动继承所有父类的便利构造器。 5.4 指定构造器和便利构造器实践1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Food &#123; var name: String init(name: String) &#123; self.name = name &#125; convenience init() &#123; self.init(name: "[Unnamed]") &#125;&#125;class RecipeIngredient: Food &#123; var quantity: Int init(name: String, quantity: Int) &#123; self.quantity = quantity super.init(name: name) &#125; override convenience init(name: String) &#123; self.init(name: name, quantity: 1) &#125;&#125;let oneMysteryItem = RecipeIngredient()let oneBacon = RecipeIngredient(name: "Bacon")let sixEggs = RecipeIngredient(name: "Eggs", quantity: 6)class ShoppingListItem: RecipeIngredient &#123; var purchased = false var description: String &#123; var output = "\(quantity) x \(name)" output += purchased ? "√" : "×" return output &#125;&#125;var breakfastList = [ ShoppingListItem(), ShoppingListItem(name: "Bacon"), ShoppingListItem(name: "Eggs", quantity: 6)]breakfastList[0].name = "Orange juice"breakfastList[0].purchased = truefor item in breakfastList &#123; print(item.description)&#125;// print //"1 x Orange juice √//1 x Bacon ×//6 x Eggs ×//" 6. 可失败构造器123456789101112131415161718192021222324struct Animal &#123; let species: String init?(species: String) &#123; if species.isEmpty &#123; return nil &#125; self.species = species &#125;&#125;let someCreature = Animal(species: "Giraffe")// someCreature 的类型是 Animal? 而不是 Animalif let giraffe = someCreature &#123; print("\(giraffe.species)")&#125;// print "Giraffe"let anonymousCreature = Animal(species: "")if anonymousCreature == nil &#123; print("not initialized")&#125;// print "not initialized" 6.1 枚举类型的可失败构造器你可以通过带一个或多个参数的可失败构造器来获取枚举类型中特定的枚举成员，如果提供的参数无法匹配任何枚举成员，则构造失败。 1234567891011121314151617181920212223242526enum TemperatureUnit &#123; case Kelvin, Celsius, Fahrenheit init?(symbol: Character) &#123; switch symbol &#123; case "K": self = .Kelvin case "C": self = .Celsius case "F": self = .Fahrenheit default: return nil &#125; &#125;&#125;let fahrenheitUnit = TemperatureUnit(symbol: "F")if fahrenheitUnit != nil &#123; print("initialization succeeded")&#125;let unknownUnit = TemperatureUnit(symbol: "X")if unknownUnit == nil &#123; print("initialization failed")&#125;// print "initialization failed" 6.2 带原始值的枚举类型的可失败构造器带原始值的枚举类型会自带一个可失败构造器init?(rawValue:)，该可失败构造器有一个名为rawValue的参数，如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构造相应的枚举成员，否则构造失败。 因此上面的例子可以重写为： 123456789101112131415enum TemperatureUnit: Character &#123; case Kelvin = "K", Celsius = "C", Fahrenheit = "F"&#125;let fahrenheitUnit = TemperatureUnit(rawValue: "F")if fahrenheitUnit != nil &#123; print("initialization succeeded.")&#125;// print "initialization succeeded."let unknownUnit = TemperatureUnit(rawValue: "X")if unknownUnit == nil &#123; print("initialization failed.")&#125;// print "initialization failed." 6.3 构造失败的传递1234567891011121314151617181920212223242526272829303132333435class Product &#123; let name: String init?(name: String) &#123; if name.isEmpty &#123;return nil&#125; self.name = name &#125;&#125;class CartItem: Product &#123; let quantity: Int init?(name:String, quantity: Int) &#123; if quantity &lt; 1 &#123;return nil&#125; self.quantity = quantity super.init(name: name) &#125;&#125;if let twoSocks = CartItem(name: "sock", quantity: 2) &#123; print("initialization succeeded")&#125;// print "initialization succeeded"if let zeroShirts = CartItem(name: "shirt", quantity: 0) &#123; print("initialization succeeded")&#125; else &#123; print("Unable to initialize")&#125;// print "Unable to initialize"if let oneUnnamed = CartItem(name: "", quantity: 1) &#123; print("initialization succeeded")&#125; else &#123; print("Unable to initialize")&#125;// print "Unable to initialize" 6.4 重写一个可失败构造器12345678910111213141516171819202122232425262728293031class Document &#123; var name: String? init() &#123; &#125; init?(name: String) &#123; if name.isEmpty &#123;return nil&#125; self.name = name &#125;&#125;class AutomaticallyNamedDocument: Document &#123; override init() &#123; super.init() self.name = "[Untitled]" &#125; override init(name: String) &#123; super.init() if name.isEmpty &#123; self.name = "[Untitled]" &#125; else &#123; self.name = name &#125; &#125;&#125;class UntitledDocument: Document &#123; override init() &#123; super.init(name: "[Untitled]") &#125;&#125; 6.5 可失败构造器init!通常来说我们通过在init关键字后添加问号的方式（init?）来定义一个可失败构造器，但你也可以通过在init后面添加惊叹号的方式来定义一个可失败构造器（init!），该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。 一旦init!构造失败，则会触发一个断言。 7. 必要构造器在类的构造器前添加required修饰符表明所有该类的子类都必须实现该构造器： 12345class SomeClass &#123; required init() &#123; // 构造器的实现代码 &#125;&#125; 在子类重写父类的必要构造器时，必须在子类的构造器前也添加required修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加override修饰符。 12345class SomeSubclass: SomeClass &#123; required init() &#123; // 构造器的实现代码 &#125;&#125; 8. 通过闭包或函数设置属性的默认值1234567class SomeClass &#123; let someProperty: SomeType = &#123; // 在这个闭包中给 someProperty 创建一个默认值 // someValue 必须和 SomeType 类型相同 return someValue &#125;()&#125; 闭包结尾的小括号告诉 Swift 立即执行次闭包，如果忽略了括号，相当于将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。 注意：如果使用闭包来初始化属性，闭包在执行时，实例的其它部分还没有初始化。这意味着你不能在闭包里访问其它属性，即使这些属性有默认值。同样，你也不能使用隐式的self属性，或者调用任何实例方法。]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>构造过程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪录片《从秦始皇到汉武帝》]]></title>
    <url>%2F%E7%BA%AA%E5%BD%95%E7%89%87%E3%80%8A%E4%BB%8E%E7%A7%A6%E5%A7%8B%E7%9A%87%E5%88%B0%E6%B1%89%E6%AD%A6%E5%B8%9D%E3%80%8B.html</url>
    <content type="text"><![CDATA[不知道为啥油管会推荐这部片子给我，难道因为我之前看了《大军师司马懿》？顺便说一句，YouTube是当今世界最懂人的视频网站，它背后的算法总能把你喜欢的视频呈现给你，而且让你沉迷于其中一个接一个的推荐视频。 看到这部片子豆瓣评分8.4分，点进去看，一开始以为是个电视剧，没想到是部颇为值得一看的纪录片。 读书的时候，政史地一直是我的薄弱项。至今我对中国的历史年表还搞不清顺序，我是抱着补充历史知识的念头去看的，也确实收获不少。 之前，秦始皇在我的印象中就只有“始皇帝”和“暴君”两个标签。现在不是这样了，嬴政在我心里成了一个伟大的历史人物。 战国时代，嬴政就能有一统天下的远见和气魄而且最终灭掉了六国，他已经开创了一个时代，足以永远地烙在历史的丰碑上。嬴政称帝后，并没有满足于现状，而是进行了大刀阔斧地改革，目的只有一个，就是不仅仅要在地域上一统天下，更要一统人心。然而天下人能懂他的太少了，社会一直处于动荡之中，他至死也没能收服天下人心。早期的秦始皇极富远见和包容之心，却一直活在世人的误解之中，�最终导致他出现“暴虐”的倾向。 郭沫若说过“百代皆行秦政”，事实确实如此，直至今日，中央集权制仍然是我国的政权制度。虽然秦朝只有十多年历史，嬴政的思想却影响后世千年直至今日。 继承了秦始皇的理想的并不是他的后人，而是他的崇拜者庶民刘邦。可惜，巍峨壮阔的咸阳城，毁在了霸王项羽手上。项羽想恢复封建秩序，而刘邦看到了秦始皇中央集权制度制度的意义，刘邦才是顺应时代发展的弄潮儿。 我们现在看历史，就像开了上帝视角。历史可以作为一面镜子，避免我们踩同样的坑。然而要顺应时代的发展，开创一个新的局面，仅仅以史为镜是不够的，必须要有超时代的眼界。后人不过是在实现秦始皇的理想帝国罢了，秦始皇是当之无愧的千古一帝。 秦始皇很早就意识到帝国统一的根本是文化的统一，然而他采取了焚书的极端方式，这样急功近利的做法为秦帝国的覆灭埋下了种子。 没想到刘氏的继承人汉武帝是用儒家思想来凝聚人心的，通过文化手段把整个社会由无为转变为进取有为，最终灭掉了匈奴，实现的华夏帝国的大一统。 看到最后一集时，油管又给我推荐了《东方帝王谷》（豆瓣9.3分）和《复活的军团》（豆瓣8.9分），时间有限就没有继续看了。这些都是陕西省的文化输出啊，我现在感觉关中地区随便找个地方挖一铲子，都可能是个帝王陵，正所谓“南方的才子北方的将，陕西的黄土埋皇上”。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>纪录片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的方法]]></title>
    <url>%2FSwift%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[结构体和美剧能够定义方法是Swift和C/OC的主要区别之一。 1. 实例方法实例方法是属于某个特定类、结构体或者枚举类型实例的方法。 123456789101112class Counter &#123; var count = 0 func increment() &#123; count += 1 &#125; func increment(by amount: Int) &#123; count += amount &#125; func reset() &#123; count = 0 &#125;&#125; 1.1 self属性类型的每一个实例都有一个隐含的属性叫做self，它完全等同于该实例本身。 上面的increment方法还可以这样写： 123func increment() &#123; self.count += 1&#125; 使用self的主要场景是实例方法的某个参数名称与实例的某个属性名称相同的时候，这种情况下，参数名称享有优先权，并且在引用属性时必须使用一种更严格的方式。 123456789101112struct Point &#123; var x = 0.0, y = 0.0 func isToTheRightOfX(x: Double) -&gt; Bool &#123; return self.x &gt; x &#125;&#125;let somePoint = Point(x: 4.0, y: 5.0)if somePoint.isToTheRightOfX(x: 1.0) &#123; print("yes")&#125;// print "yes" 1.2 在实例方法中修改值类型结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改。 但是，如果你确实需要在某个特定的方法中修改结构体或者枚举的属性，你可以为这个方法选择可变(mutating)行为，然后就可以从其方法内部改变它的属性；并且这个方法做的任何改变都会在方法执行结束时写回到原始 结构中。方法还可以给它隐含的self属性赋予一个全新的实例，这个新实例在方法结束时会替换现存实例。 要使用可变方法，将关键字mutating放到方法的func关键字之前就可以了： 1234567891011struct Point &#123; var x = 0.0, y = 0.0 mutating func moveByX(deltaX: Double, y deltaY: Double) &#123; x += deltaX y += deltaY &#125;&#125;var somePoint = Point(x: 1.0, y: 1.0)somePoint.moveByX(deltaX: 2.0, y: 3.0)print("The point is now at (\(somePoint.x), \(somePoint.y))")// print "The point is now at (3.0, 4.0)" 1.3 在可变方法中给self赋值可变方法能够赋给隐含属性self一个全新的实例。 123456struct Point &#123; var x = 0.0, y = 0.0 mutating func moveBy(x deltaX: Double, y deltaY: Double) &#123; self = Point(x: x + deltaX, y: y + deltaY) &#125;&#125; 调用moveBy(x:y:)方法和上面的方法结果是一样的。 枚举的可变方法可以把self设置为同一枚举类型中不同的成员： 12345678910111213enum TriStateSwitch &#123; case Off, Low, High mutating func next() &#123; switch self &#123; case .Off: self = .Low case .Low: self = .High case .High: self = .Off &#125; &#125;&#125; 2. 类型方法在方法的func关键字之前加上关键字static，来指定类型方法。类还可以用关键字class来允许子类重写父类的方法实现。 123456789101112131415161718192021222324struct LevelTracker &#123; static var highestUnlockedLevel = 1 var currentLevel = 1 static func unlock(_ level: Int) &#123; if level &gt; highestUnlockedLevel &#123; highestUnlockedLevel = level &#125; &#125; static func isUnlocked(_ level: Int) -&gt; Bool &#123; return level &lt;= highestUnlockedLevel &#125; @discardableResult mutating func advance(to level: Int) -&gt; Bool &#123; if LevelTracker.isUnlocked(level) &#123; currentLevel = level return true &#125; else &#123; return false &#125; &#125;&#125; 注：@discardableResult告诉编译器此方法可以不用接收返回值。 1234567891011class Player &#123; var tracker = LevelTracker() let playName: String func complete(level: Int) &#123; LevelTracker.unlock(level + 1) tracker.advance(to: level + 1) &#125; init(name: String) &#123; playName = name &#125;&#125; Player类创建一个新的LevelTracker实例来检测这个用户的进度。它提供了complete(level:)方法，一旦玩家完成某个指定等级就调用它。]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的属性]]></title>
    <url>%2FSwift%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7.html</url>
    <content type="text"><![CDATA[1. 存储属性简单来说，每一个存储属性就是存储在特定类或结构体实例里的一个常量或变量。存储属性可以使变量存储属性，也可以是常量存储属性。 1.1 常量结构体的存储属性结构体属于值类型，值类型的实例被声明为常量的时候，它所有的属性也就成了常量。 而引用类型的类则不一样，把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性。 1.2 延迟存储属性延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用lazy来标示一个延迟存储属性。 注意：必须将延迟存储属性声明成变量（使用var关键字），因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。 延迟属性很有用，当属性的值依赖于在实例的构造过程结束后才会知道影响值的外部因素时，或者当获得属性的初始值需要复杂或大量计算时，可以只在需要的时候计算它。 12345678910111213class DataImporter &#123; var fileName = "data.txt"&#125;class DataManager &#123; lazy var importer = DataImporter() var data = [String]()&#125;let manager = DataManager()manager.data.append("Some data")manager.data.append("Some more data")// DataImporter 实例的 importer 属性还没有被创建 由于使用了lazy，importer属性只有在第一次被访问的时候才被创建。比如访问它的属性fileName时：1print(manager.importer.fileName) 注意：如果一个被标记为lazy的属性没有被初始化就同时被多个线程访问，则无法保证该属性只会被初始化一次。 1.3 存储属性和实例变量如果您有过 Objective-C 经验，应该知道 Objective-C 为类实例存储值和引用提供两种方法。除了属性之 外，还可以使用实例变量作为属性值的后端存储。 Swift 编程语言中把这些理论统一用属性来实现。Swift 中的属性没有对应的实例变量，属性的后端存储也无法 直接访问。这就避免了不同场景下访问方式的困扰，同时也将属性的定义简化成一个语句。属性的全部信 息——包括命名、类型和内存管理特征——都在唯一一个地方(类型定义中)定义。 2. 计算属性除存储属性外，类、结构体和枚举可以定义计算属性。计算属性不直接存储值，而是提供一个getter和一个可选的setter，来间接获取和设置其他属性或变量的值。 123456789101112131415161718192021222324252627struct Point &#123; var x = 0.0, y = 0.0&#125;struct Size &#123; var width = 0.0, height = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size() var center: Point &#123; get &#123; let centerX = origin.x + (size.width / 2) let centerY = origin.y + (size.height / 2) return Point(x: centerX, y: centerY) &#125; set(newCenter) &#123; origin.x = newCenter.x - (size.width / 2) origin.y = newCenter.y - (size.height / 2) &#125; &#125;&#125;var square = Rect(origin: Point(x: 0.0, y: 0.0), size: Size(width: 10.0, height: 10.0))let initialSquareCenter = square.centersquare.center = Point(x: 15.0, y: 15.0)print("square.origin is now at (\(square.origin.x), \(square.origin.y))")// 打印 "square.origin is now at (10.0, 10.0)” 2.1 简化setter声明如果计算属性的setter没有定义表示新值的参数名，则可以使用默认名称newValue。下面是简化setter声明的Rect结构体代码： 123456789101112131415struct AlternativeRect &#123; var origin = Point() var size = Size() var center: Point &#123; get &#123; let centerX = origin.x + (size.width / 2) let centerY = origin.y + (size.height / 2) return Point(x: centerX, y: centerY) &#125; set &#123; origin.x = newValue.x - (size.width / 2) origin.y = newValue.y - (size.height / 2) &#125; &#125;&#125; 2.2 只读计算属性只有getter没有setter的计算属性就是只读计算属性。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。 注意：必须使用 var 关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。let 关键字只用来声明 常量属性，表示初始化后再也无法修改的值。 只读计算属性的声明可以去掉get关键字和花括号: 123456789struct Cuboid &#123; var width = 0.0, height = 0.0, depth = 0.0 var volume: Double &#123; return width * height * depth &#125;&#125;let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)print("the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)")// 打印 "the volume of fourByFiveByTwo is 40.0" 3. 属性观察器属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外。 willSet在新的值被设置之前调用 didSet在新的值被设置之后立即调用 注意：父类的属性在子类的构造器中被赋值时，它在父类中的willSet和didSet观察器会被调用，随后才会调用子类的观察器。在父类初始化方法调用之前，子类给属性赋值时，观察器不会被调用。 1234567891011121314151617181920212223class StepCounter &#123; var totalSteps: Int = 0 &#123; willSet(newTotalSteps) &#123; print("About to set totalSteps to \(newTotalSteps)") &#125; didSet &#123; if totalSteps &gt; oldValue &#123; print("Addedd \(totalSteps - oldValue) steps") &#125; &#125; &#125;&#125;let stepCounter = StepCounter()stepCounter.totalSteps = 200// About to set totalSteps to 200// Added 200 stepsstepCounter.totalSteps = 360// About to set totalSteps to 360// Added 160 stepsstepCounter.totalSteps = 896// About to set totalSteps to 896// Added 536 steps 注意：如果将属性通过in-out方式传入函数，willSet和didSet也会调用。这是因为in-out参数采用了拷入拷出模式:即在函数内部使用的是参数的copy，函数结束后，又对参数重新赋值。 4. 全局变量和局部变量全局的常量或变量都是延迟计算的，不同的地方在于，全局的常量或变量不需要标记lazy修饰符。 局部范围的常量或变量从不延迟计算。 5. 类型属性实例属性属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立。 也可以为类型本身定义属性，无论创建了多少个该类型的实例，这些属性都只有唯一一份。这种属性就是类型属性。 类型属性用于定义某个类型所有实例共享的数据，比如所有实例都能用的一个常量(就像 C 语言中的静态常 量)，或者所有实例都能访问的一个变量(就像 C 语言中的静态变量)。 存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算型属性一样只能定义成变量属性。 注意：跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过 程中使用构造器给类型属性赋值。存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访 问，系统也保证只会对其进行一次初始化，并且不需要对其使用lazy修饰符。 5.1 类型属性语法使用关键字static来定义类型属性。在为类定义计算型类型属性时，可以改用关键字class来支持子类对父 类的实现进行重写。下面的例子演示了存储型和计算型类型属性的语法: 1234567891011121314151617181920212223struct SomeStructure &#123; static var storedTypeProperty = "Some Value." static var computedTypeProperty: Int &#123; return 1 &#125;&#125;enum SomeEnumeration &#123; static var storedTypeProperty = "Some Value." static var computedTypeProperty: Int &#123; return 6 &#125;&#125;class SomeClass &#123; static var storedTypeProperty = "Some Value." static var computedTypeProperty: Int &#123; return 27 &#125; class var overrideableComputedTypeProperty: Int &#123; return 107 &#125;&#125; 5.2 获取和设置类型属性的值跟实例属性一样，类型属性也是通过点运算符来访问。但是，类型属性是通过类型本身来访问，而不是通过实例。 123456789101112131415161718192021222324252627282930struct AudioChannel &#123; static let thresholdLEvel = 10 static var maxInputLevelForAllChannels = 0 var currentLevel: Int = 0 &#123; didSet &#123; if currentLevel &gt; AudioChannel.thresholdLEvel &#123; currentLevel = AudioChannel.thresholdLEvel &#125; if currentLevel &gt; AudioChannel.maxInputLevelForAllChannels &#123; AudioChannel.maxInputLevelForAllChannels = currentLevel &#125; &#125; &#125;&#125;var leftChannel = AudioChannel()var rightChannel = AudioChannel()leftChannel.currentLevel = 7print(leftChannel.currentLevel)// print "7"print(AudioChannel.maxInputLevelForAllChannels)// print "7"rightChannel.currentLevel = 11print(rightChannel.currentLevel)// print "10"print(AudioChannel.maxInputLevelForAllChannels)// print "10"]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git中文显示乱码的解决方案（Mac）]]></title>
    <url>%2FGit%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E4%B9%B1%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88Mac%EF%BC%89.html</url>
    <content type="text"><![CDATA[终端运行以下命令即可： 1git config --global core.quotepath false]]></content>
      <categories>
        <category>trick</category>
      </categories>
      <tags>
        <tag>trick</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《奔跑吧，奥沙利文》]]></title>
    <url>%2F%E8%AF%BB%E3%80%8A%E5%A5%94%E8%B7%91%E5%90%A7%EF%BC%8C%E5%A5%A5%E6%B2%99%E5%88%A9%E6%96%87%E3%80%8B.html</url>
    <content type="text"><![CDATA[只用了三个晚上，就读完了这本书，这应该是我有史以来最快的读书速度了。因为他是我的偶像，我为之着迷。 “跑步是我的信仰体系，是我赖以保持内心平静的途径。跑步的过程身体是痛苦难耐的，但跑步又是让我达到精神高度的最佳途径。”这段话出现在书的开头，我认为是全书精华所在。当我读到这里的时候，引起了我的一些共鸣。 国人大多是不爱运动的，我从小也没什么运动天赋，也从未痴迷于某项运动。因我从小体弱多病，父亲为我常年寻医问药，后来才从一个瘦猴变成了一个微胖的小伙。高中开始失眠抑郁，直至今日亦是如此。所以一直以来我从未真正地感受过健康的状态，我最好的状态大概是我大学末期去健身房锻炼的某个学期。我并不以肌肉男为目的，而是刷脂减肥，果然后来瘦了，整个人的精神状态提升了不少，连颜值都涨了不少。这使我深信，运动可以改变一个人，它可以让你变得更好。 我天性自由散漫，很难在一件事情上常年坚持。自从那个健身的学期之后，运动成了间歇性的爱好。运动尝到的甜头还是输给了自我放逐，我从来都没有达到过满意的身材。我不是那种凡是去做就一定要做第一的人，总的来说，我思想算是比较中庸，自然就会显得很平庸。我想我应该改变一些，让自己变得更追求完美可能会更好。 从8月初到现在9月末，我不知道最近到底过得什么日子。沉迷游戏，逃避现实和孤独，没有任何运动，睡眠严重不足，工作和学习效率低下，恶性循环。。。然而心底却一直有个声音告诉自己不能放弃治疗，需要做出改变。 我试图从书中去汲取力量，确实效果不错。读完了《奔跑吧，奥沙利文》，给了我很多启发和动力，我也对火老师有了更多的了解。他就是那么个真性情的人，我想我应该活得简单点，真实而温暖足矣。 奔跑吧，去寻找真实的自我！]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>奥沙利文</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的类和结构体]]></title>
    <url>%2FSwift%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93.html</url>
    <content type="text"><![CDATA[1. 类和结构体对比1.1 定义语法你每次定义一个新类或者结构体的时候，实际上你是定义了一个新的Swift类型。因此请使用UpperCamelCase这种方式来命名（如SomeClass和SomeStructure等），以便符合标准Swift类型的大写命名风格（如String，Int和Bool） 定义类和结构体示例： 1234567891011struct Resolution &#123; var width = 0 var height = 0&#125;class VideoMode &#123; var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String?&#125; 类和结构体实例： 12let someResolution = Resolution()let someVideoMode = VideoMode() 结构体类型的成员逐一构造器： 1let vga = Resolution(width: 640, height: 480) 与结构体不同，类实例没有默认的成员逐一构造器。 1.2 结构体和枚举是值类型值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。 12345678let hd = Resolution(width: 1920, height: 1080)var cinema = hdcinema.width = 2048print(hd)print(cinema)// print "Resolution(width: 1920, height: 1080)"// print "Resolution(width: 2048, height: 1080)" 枚举也是值类型。 在Swift中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。 1.3 类是引用类型与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。 如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift 内建了两个恒等运算符： 等价于（===） 不等价于（!==） 1.4 类和结构体的选择按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体： 该数据结构的主要目的是用来封装少量相关简单数据值。 有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。 该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。 该数据结构不需要去继承另一个既有类型的属性或者行为。 1.5 字符串、数组、和字典类型的赋值与复制行为Swift 中，许多基本类型，诸如String，Array和Dictionary类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。 Objective-C 中NSString，NSArray和NSDictionary类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。 注意以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。然而，Swift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化。]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>类</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS小贴士]]></title>
    <url>%2FiOS%E5%B0%8F%E8%B4%B4%E5%A3%AB.html</url>
    <content type="text"><![CDATA[隐藏导航栏横线1234567891011121314151617181920212223242526272829303132333435363738@interface ViewController ()@property (nonatomic, strong) UIImageView *navBarHairlineImageView;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.navBarHairlineImageView = [self findHairlineImageViewUnder:self.navigationController.navigationBar];&#125;- (UIImageView *)findHairlineImageViewUnder:(UIView *)view &#123; if ([view isKindOfClass:UIImageView.class] &amp;&amp; view.bounds.size.height &lt;= 1.0) &#123; return (UIImageView *)view; &#125; for (UIView *subview in view.subviews) &#123; UIImageView *imageView = [self findHairlineImageViewUnder:subview]; if (imageView) &#123; return imageView; &#125; &#125; return nil;&#125;- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; self.navBarHairlineImageView.hidden = YES;&#125;- (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; self.navBarHairlineImageView.hidden = NO;&#125; Storyboard勾选Hide-Bottom-Bar-on-Push带来黑影问题去掉”Hide Bottom Bar on Push”前面的勾，在相应的控制器中使用代码来实现tabbar的显示和隐藏，即分别在viewWillAppear和viewWillDisappear方法中实现所需要的效果。 判定viewWillDisappear是push还是pop1234567if ([self.navigationController.viewControllers indexOfObject:self] == NSNotFound) &#123; //pop [self.navigationController setNavigationBarHidden:YES animated:YES]&#125; else &#123; //push [self.navigationController setNavigationBarHidden:NO animated:YES];&#125; 自定义导航栏返回箭头导致返回手势失效在自定义导航控制器viewDidLoad方法中加入如下代码：1self.interactivePopGestureRecognizer.delegate = (id)self; 自定义导航栏为渐变色在自定义导航控制器中设置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#pragma mark - life cycle- (void)viewDidLoad &#123; [super viewDidLoad]; [self setBarBackgroundColor];&#125;#pragma mark - private method- (void)setBarBackgroundColor &#123; for (UIView *view in self.navigationBar.subviews) &#123; if ([view isKindOfClass:NSClassFromString(@"_UIBarBackground")] || [view isKindOfClass:NSClassFromString(@"_UINavigationBarBackground")]) &#123; NSString *phoneVersion = [[UIDevice currentDevice] systemVersion]; UIView *iView = nil; if (phoneVersion.floatValue &lt; 10.0) &#123; iView = view; &#125; else &#123; for (UIView *subView in view.subviews) &#123; if ([subView isKindOfClass:[UIVisualEffectView class]]) &#123; iView = subView; &#125; &#125; &#125; CRLog(@"it is"); CGRect frame = iView.frame; CRLog(@"%@", NSStringFromCGRect(frame)); UIView *alphaView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, frame.size.width, frame.size.height + 20)]; alphaView.backgroundColor = [UIColor whiteColor]; alphaView.userInteractionEnabled = NO; [iView addSubview:alphaView]; [self setShadeColorWithView:alphaView]; &#125; &#125;&#125;- (void)setShadeColorWithView:(UIView *)view &#123; CAGradientLayer *gradientLayer = [CAGradientLayer layer]; gradientLayer.startPoint = CGPointMake(0, .5); gradientLayer.endPoint = CGPointMake(1, .5); gradientLayer.colors = @[(id)RGBA(76, 202, 90, 1).CGColor,(id)RGBA(39, 182, 112, 1).CGColor]; gradientLayer.frame = view.bounds; [view.layer addSublayer:gradientLayer];&#125; 全局设置导航控制器返回按钮在自定义导航控制器中做如下拦截处理：123456789101112- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated &#123; UIImage *image = [[UIImage imageNamed:@"backButton_background"] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]; viewController.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithImage:image style:UIBarButtonItemStyleDone target:self action:@selector(back)]; [super pushViewController:viewController animated:animated];&#125;#pragma mark - back- (void)back &#123; [self popViewControllerAnimated:YES];&#125; 通过Scheme区分管理Debug和Release环境 1、 新建两个Scheme，分别为 projectName-Debug 和 projectName-Release ，编辑对应的Scheme，将 Build Configuration 分别改为 Debug 和 Release。 2、 在PCH文件中添加如下宏定义：12345#ifdef DEBUG#define kServer @"http://192.168.0.1:8080"#else#define kServer @"http://xxoo.com"#endif Sample code:demo/Debug&amp;Release-Demo PCH常用宏定义12345678910111213141516171819202122#define RGBA(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:a]#define KSColor(r, g, b) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1.0]#define KSRandomColor CRColor(arc4random_uniform(256), arc4random_uniform(256), arc4random_uniform(256))#define kCellSeparateColor RGBA(200, 199, 204, 1)#ifdef DEBUG#define KSLog(...) NSLog(@"%s %d \n %@ \n\n",__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])#define kServer @"http://192.168.1.xx"#else#define KSLog(...) #define kServer @"http://xx.com"#endif#define kIsPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)#define kFontSize12 kIsPad ? [UIFont systemFontOfSize:14] : [UIFont systemFontOfSize:12]#define kFontSize14 kIsPad ? [UIFont systemFontOfSize:16] : [UIFont systemFontOfSize:14]#define kFontSize16 kIsPad ? [UIFont systemFontOfSize:18] : [UIFont systemFontOfSize:16]#define kFontSize18 kIsPad ? [UIFont systemFontOfSize:20] : [UIFont systemFontOfSize:18]#define kLastWindow [[UIApplication sharedApplication].windows lastObject]]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>小贴士</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode 工程 Git配置参考]]></title>
    <url>%2FXcode-%E5%B7%A5%E7%A8%8B-Git%E9%85%8D%E7%BD%AE%E5%8F%82%E8%80%83.html</url>
    <content type="text"><![CDATA[全局配置1、根目录下touch .gitignore_global2、在创建的文件中写入如下内容：123456789# .gitignore_global.DS_Store.DS_Store?*.DS_Store*/.DS_Store*/.xcuserstate*.xcuserstate 3、打开根目录下的.gitconfig，添加如下内容：12[core] excludesfile = /Users/mac/.gitignore_global 1、注意：mac替换成你自己的电脑名称 顺便把以下内容一起写入：12[alias] lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' 这段文字的意思是给git log配置一个别名：git lg，可以更优雅地显示提交日志，不信你试试。当然，原有的git log可以正常使用。 工程配置1、在工程目录下touch .gitignore2、在Github上的忽略配置上找到对应的忽略配置，写入.gitignore 其他问题如果本地或远端已经产生需要忽略的文件，问题仍然没有得到解决。 作如下操作： git rm --cached file_path git commit -m &quot;xxoo&quot; git push 注意：git rm --cached file_path只是删除暂存区的文件，本地的文件不会删除，而git rm file_path则会删除文件。]]></content>
      <categories>
        <category>trick</category>
      </categories>
      <tags>
        <tag>trick</tag>
        <tag>git</tag>
        <tag>xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的枚举]]></title>
    <url>%2FSwift%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE.html</url>
    <content type="text"><![CDATA[1. 枚举的关联值1234567891011121314151617enum BarCode &#123; case upc(Int, Int, Int, Int) case qrCode(String)&#125;var productBarcode = Barcode.upc(8, 85909, 51226, 3)productBarcode = .qrCode("ABCDEFGHIJKLMNOP")switch productBarcode &#123;case let .upc(numberSystem, manufacturer, product, check): print("UPC: \(numberSystem), \(manufacturer), \(product), \(check).")case let .qrCode(productCode): print("QR code: \(productCode).")&#125;// 输出 "QR code: ABCDEFGHIJKLMNOP.// case let .upc(numberSystem, manufacturer, product, check) 等同于 case .upc(let numberSystem, let manufacturer, let product, let check) 2. 原始值12345enum ASCIIControlCharacter: Character &#123; case tab = "\t" case lineFeed = "\n" case carriageReturn = "\r"&#125; 2.1 原始值的隐式赋值123enum Planet: Int &#123; case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune&#125; 在上面的例子中，Plant.mercury的显式原始值为1，Planet.venus的隐式原始值为2，依次类推。 1234567enum CompassPoint: String &#123; case north, south, east, west&#125;let sunsetDirection = CompassPoint.west.rawValueprint(sunsetDirection)// print "west\n" 2.2 使用原始值初始化枚举实例123456enum Planet:Int &#123; case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune&#125;let possiblePlanet = Planet(rawValue: 7)// possiblePlanet = uranus 注意:原始值构造器是一个可失败构造器，因为并不是每一个原始值都有与之对应的枚举成员。 123456if let positionToFind = Planet(rawValue: 11) &#123; print(positionToFind)&#125; else &#123; print("no position")&#125;// print "no position\n"]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017中锦赛记忆]]></title>
    <url>%2F2017%E4%B8%AD%E9%94%A6%E8%B5%9B%E8%AE%B0%E5%BF%86.html</url>
    <content type="text"><![CDATA[好久没写文章了，错过了香港大师赛，中英对抗赛，这次中锦赛选择性地看了一些场次的比赛，而且去现场见到了“神”的真身 ：） 顺便吐槽一下，中英对抗赛的组委会举办地一塌糊涂，被观众恶评为史上最糟糕的比赛。 说回中锦赛，去年的中锦赛是邀请赛，本来我也想去现场看的，正好是火老师对巫师。结果，火老师没来参赛，我就没买票。后来希胖夺冠拿走了高额的奖金，记得当时希胖笑的很灿烂。今年升级为排名赛了，奖金依然丰厚，恒大不差钱嘛，吸引了各大高手来参赛。 【第二轮】 周跃龙5-4淘汰世界第一塞尔比，并奉献了全场唯一一杆破百（124）。 床铺打出两杆破百，仍遭多特5-3淘汰，万众期待的特奥会也因此落空，多特第三轮迎战火老师。 希胖状态不佳，败于汤姆·福德，止步第二轮。 【第三轮】 周跃龙击败古尔德晋级。墨菲状态早出，5-0剃了马奎尔光头。火老师也是兵不血刃，5-0血洗多特。 【四分之一决赛】 稳定先生墨菲狙击了Jump Dragon。李行击败了威廉姆斯顺利进入半决赛，这场比赛，威廉姆斯受现场观众影响比较大，马叔脾气向来不太好，怨言颇多。不过观众素质确实差，给球员造成非常不好的影响。卢卡1-4落后火老师的情况下，接连打出两杆破百并逆转成功进入半决赛对阵李行。 顺便提一句，中国的新生代涌现出不少优秀的球员，这些人里面，我认为，周跃龙的潜力是最大的，纯属个人感觉~ 【半决赛】 卢卡和李行战至决胜局，一局定胜负，两人都有压力。这是李行职业生涯的最好成绩，这是他创造历史的机会。台面出现一个远台进攻的机会，李行定定神，上前一步，趴下，瞄球，运杆，砰！一声清亮的响袋声，白球死死地定在那里，完美的叫黑球位。我看的是任浩江老师的直播，他激动地狂吼“好球”时吓了我一跳。。。很少见到他这么激烈地解说呢。然而，李行马上出现了一个致命的简单红球失误，令观众唏嘘和遗憾不已，卢卡收下了大礼，直接超分。技术上没问题，我觉得更多地可能是心态上的问题。祝贺李行打出职业生涯新高，这次中锦赛应该给他增加了不少比赛经验。 【决赛】 决赛显得有点无趣，墨菲和卢卡状态都不是很好，两人零敲碎打。卢卡最终拿下比赛，恭喜获得首个排名赛冠军。 本次比赛最大的关键词应该非“爆冷”莫属，TOP16悉数出局，令人惋惜。 这是我第一次去现场看球，值得纪念的时刻。放票前我就仔细核对了签表，大麦网一放票，我就购得正对一号台的绝佳位置。根据我的推测，若无爆冷，一号台不是丁俊晖就是特奥会。却总是事与愿违，丁丁惨遭5-0血洗，床铺也出局了。不过如果丁丁不出局，火老师可能就不在一号台了。很幸运地，我在现场见到了神的真身。火老师年纪虽然大了，比之前稍胖然而身材依然很好，打起球来依然是行云流水，闲庭信步。我在现场见证了火老师的第881杆破百，以后估计很难现场再见了。有生之年，火老师的球，看多一场，就是少了一场。 本次比赛直播平台是巨星在线，巨星在线是瑞盖集团旗下专注于斯诺克的产品。据说瑞盖与世界斯诺克协会签订了10年的网络直播版权，以后看球更方便了。然而，巨星在线的PC和APP端经常出现问题，希望技术人员能尽快完善。 另外，通过我个人去现场和看直播的感觉来看，斯诺克的推广和观众素质有待提高，这条路仍然任重道远。斯诺克一直被英国人霸占世界之巅多年，打球最多的也是英国人。现在中国崛起了，还有部分泰国、澳大利亚、比利时等国家的少量选手也活跃在世界舞台，然而相对其他体育运动，斯诺克的普及程度是远远不够的，斯诺克未开发的市场依然巨大。 老规矩，送上福利视频，火老师第881杆破百，Enjoy it~]]></content>
      <categories>
        <category>snooker</category>
      </categories>
      <tags>
        <tag>snooker</tag>
        <tag>中锦赛</tag>
        <tag>奥沙利文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 终端配置：oh-my-zsh + Solarized 配色方案]]></title>
    <url>%2FMac-%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%EF%BC%9Aoh-my-zsh-Solarized-%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88.html</url>
    <content type="text"><![CDATA[1. 安装 oh-my-zsh2. 下载solarized3. 打开终端 -&gt; 偏好设置 -&gt; 描述文件 -&gt; 导入文件，导入 solarized/osx-terminal.app-colors-solarized/Solarized Dark ansi.terminal，设置通用下的默认描述文件为Solarized Dark ansi。 4. 附：git log 配置：终端运行：1git config --global alias.lg "log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'" 重启终端即可。]]></content>
      <categories>
        <category>trick</category>
      </categories>
      <tags>
        <tag>trick</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的高阶函数：Map、Filter、Reduce和FlatMap]]></title>
    <url>%2FSwift%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%EF%BC%9AMap%E3%80%81Filter%E3%80%81Reduce%E5%92%8CFlatMap.html</url>
    <content type="text"><![CDATA[Map使用 map 来遍历集合并对集合中每一个元素进行同样的操作。 123let arr = [1, 2, 3]let squares = arr.map&#123;$0 * $0&#125;// print [1, 4, 9] Filterfilter函数会遍历一个集合，并返回一个数组,其中包含了集合中满足过滤条件的元素。 123let result = array.filter&#123; $0 % 2 == 0&#125; Reduce组合集合中的所有元素并返回一个非集合类型的值 123let items = [2.0,4.0,5.0,7.0]let total = items.reduce(10.0,+)// 28.0 FlatMap将一个二维数组拆开展平 123let collections = [[5,2,7],[4,8],[9,1,3]]let flat = collections.flatMap &#123; $0 &#125;// [5, 2, 7, 4, 8, 9, 1, 3] 它可以判断集合中的不可选值，并将不可选值移出集合： 123let people: [String?] = ["Tom",nil,"Peter",nil,"Harry"]let valid = people.flatMap &#123;$0&#125;// ["Tom", "Peter", "Harry"]]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的函数]]></title>
    <url>%2FSwift%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0.html</url>
    <content type="text"><![CDATA[1. 函数的参数与返回值1.1 多重返回值函数你可以用元组（tuple）类型让多个值作为一个复合值从函数中返 回。 123456789101112131415161718func minMax(array: [Int]) -&gt; (min: Int, max: Int) &#123; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return(currentMin, currentMax)&#125;let bounds = minMax(array: [8, -6, 2, 109, 3, 71])print("min is \(bounds.min) and max is \(bounds.max)")// 输出 "min is -6 and max is 109" 1.2 可选元组返回类型如果函数返回的元组类型有可能整个元组都“没有值”，你可以使用可选的（optional）元组返回类型反映整个元组可以是nil的事实。 注意：可选元组类型如(Int, Int)?与元组包含的可选类型如(Int?, Int?)是不同的。可选的元祖类型，整个元组是可选的，而不只是元组中的每个元素值。 前面的minMax(array:)函数没有对传入的数组进行任何安全检查，如果array是个空数组，会触发一个运行时错误，使用可选元组返回类型，可以安全地处理这个问题。 1234567891011121314151617func minMax(array: [Int]) -&gt; (min: Int, max: Int)? &#123; if array.isEmpty &#123; return nil &#125; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return(currentMin, currentMax)&#125; 你可以使用可选绑定来检查minMax(array:)函数返回的是一个存在的元组还是nil： 1234if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) &#123; print("min is \(bounds.min) and max is \(bounds.max)")&#125;// 输出 "min is -6 and max is 109" 2.函数参数标签和参数名称2.1 指定参数标签123func greet(person: String, from hometown: String) -&gt; String &#123; return "Hello \(person)! Glad you could visit from \(hometown)"&#125; from就是参数标签，hometown则是参数名称。 如果你希望忽略某个参数标签，可以使用_来代替一个标签。 2.2 默认参数值1234567func greet(person: String, from hometown: String = "Dream") -&gt; String &#123; return "Hello \(person)! Glad you could visit from \(hometown)"&#125;greet(person: "John")// 输出 "Hello John! Glad you could visit from Dream" 2.3 可变参数一个可变参数可以接受零个或多个值，通过在变量类型名后面加入（...）的方式来定义可变参数。 可变参数的传入值在函数体中变为此类型的一个数组。 下面这个函数用来计算一组任意长度数字的算术平均数： 12345678910func arithmeticMean(_ numbers: Double...) -&gt; Double &#123; var total: Double = 0 for number in numbers &#123; total += number &#125; return total / Double(numbers.count)&#125;arithmeticMean(1, 2, 3, 4, 5)// 返回 3.0 注意：一个函数最多只能拥有一个可变参数 2.4 输入输出参数函数参数默认是常量，试图在函数体中更改参数值将会导致编译错误。如果你想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就应该把这个参数定义为输入输出参数。 定义一个输入输出参数时，在参数定义前加inout关键字。一个输入输出参数有传入函数的值，这个值被函数修改，然后被传出函数，替换原来的值。 你只能传递变量给输入输出参数，常量或者字面量是不能被修改的。当传入的参数作为输入输出参数时，需要在参数名前加&amp;符，表示这个值可以被函数修改。 注意：输入输出参数不能有默认值，而且可变参数不能用inout标记。 123456789101112func swapTowInts(_ a: inout Int, _ b: inout Int) &#123; let temporaryA = a a = b b = temporaryA&#125;var someInt = 3var anotherInt = 107swapTowInts(&amp;someInt, &amp;anotherInt)print("someInt is now \(someInt), anotherInt is now \(anotherInt)")// 输出 "someInt is now 107, anotherInt is now 3\n" 注意：输入输出参数和返回值是不一样的。上面的swapTwoInts函数并没有定义任何返回值，但是仍然修改了someInt和anotherInt的值。输入输出参数是函数对函数体外产生影响的另一种方式。 3.函数类型每个函数都有特定的函数类型，函数的类型由函数的参数类型和返回类型组成。 1234567func addTwoInts(_ a: Int, _ b: Int) -&gt; Int &#123; return a + b&#125;func multipyTwoInts(_ a: Int, _ b: Int) -&gt; Int &#123; return a * b&#125; 上面这两个函数的类型是(Int, Int) -&gt; Int，可以解读为“这个函数类型有两个Int型参数并返回一个Int型的值”。 123func printHelloWordl() &#123; print("Hello world!")&#125; 上面这个函数的类型是：() -&gt; Void，或者叫做“没有参数，并返回Void类型的函数“。 3.1 使用函数类型在Swift中，使用函数类型就像使用其他类型一样。例如，你可以定义一个类型为函数的常量或变量，并将适当的函数赋值给它： 1var mathFunction:(Int ,Int) -&gt; Int = addTwoInts 这段代码可以被解读为：“定义一个叫做mathFunciton的变量，类型是‘一个有两个Int型的参数并返回一个Int型的值的函数‘，并让这个新变量指向addTwoInts函数”。 12print("Result: \(mathFunction(2, 3))")// 输出 "Result: 5\n" 有相同匹配类型的不同函数可以被赋值给同一个变量： 123mathFunction = multipyTwoIntsprint("Result: \(mathFunction(2, 3))")// 输出 "Result: 6\n" 就像其他类型一样，当赋值一个函数给常量或变量时，你可以让Swift来推断其函数类型： 123let anotherMathFunction = addTwoIntsprint("\(anotherMathFunction(1, 2))")// 输出 "3\n" 3.2 函数类型作为参数类型123456func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) &#123; print("Result: \(mathFunction(a, b))")&#125;printMathResult(addTwoInts, 3, 5)// 打印 "Result: 8\n" 3.3 函数类型作为返回类型12345678910111213141516171819202122232425262728func stepForward(_ input: Int) -&gt; Int &#123; return input + 1&#125;func stepBackward(_ input: Int) -&gt; Int &#123; return input - 1&#125;func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123; return backward ? stepBackward : stepForward&#125;var currentValue = 3let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)// moveNearerToZero 现在指向 stepBackward()print("Counting to zero:")// Counting to zero:while currentValue != 0 &#123; print("\(currentValue)... ") currentValue = moveNearerToZero(currentValue)&#125;print("zero")// 3...// 2...// 1...// zero! 3.4 嵌套函数目前为止你见到的所有函数都是全局函数，你也可以把函数定义在别的函数体中，称作嵌套函数。 默认情况下，嵌套函数对外是不可见的，但是可以被它们的外围函数调用。一个外围函数也可以返回它的某一个嵌套函数，使得这个函数可以在其他域中被使用。 12345678910111213141516171819func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123; func stepForward(input: Int) -&gt; Int &#123; return input + 1 &#125; func stepBackward(input: Int) -&gt; Int &#123; return input - 1 &#125; return backward ? stepBackward : stepForward&#125;var currentValue = -4let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)while currentValue != 0 &#123; print("\(currentValue)... ") currentValue = moveNearerToZero(currentValue)&#125;print("zero!")// -4...// -3...// -2...// -1...// zero!]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安装Python3和PyCharm更换Python版本]]></title>
    <url>%2FMac%E5%AE%89%E8%A3%85Python3%E5%92%8CPyCharm%E6%9B%B4%E6%8D%A2Python%E7%89%88%E6%9C%AC.html</url>
    <content type="text"><![CDATA[打开终端，Homebrew（自行Google）一行命令安装Python3：1brew install python3 安装完成后，打开PyCharm偏好设置，找到Project interpreter，即可更换python版本。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的控制流]]></title>
    <url>%2FSwift%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81.html</url>
    <content type="text"><![CDATA[1. For-In循环for-in循环中如果我们不需要知道每一次循环中计数器具体的值，用下划线_替代循环中的变量，能够忽略当前值。 123456let base = 3let power = 10var answer = 1for _ in 1...power &#123; answer *= base&#125; 2. While循环while循环在这里忽略讲解，主要说说while循环的另一种形式repeat-while，它和while的区别是在判断循环条件之前，先执行一次循环代码块，然后重复循环直到条件为false，类似于其他语言中的do-while。 3. 条件语句Swift提供两种类型的条件语句：If语句和switch语句。 switch语句不需要再case分支中显式地使用break，不存在隐式贯穿，每个case分支都必须包含至少一条语句。 单个case语句可以复合匹配和区间匹配。 4. 元组略。 5. 值绑定123456789let anotherPoint = (2, 0)switch anotherPoint &#123;case (let x, 0): print("on the x-axis with an x value of \(x)")case (0, let y): print("on the y-axis with a y value of \(y)")case let (x, y): print("somewhere else at (\(x), \(y))")&#125; 6. Wherecase分支的模式可以用where语句来判断额外的条件。 123456789let yetAnotherPoint = (1, -1)switch yetAnotherPoint &#123;case let (x, y) where x == y: print("(\(x), \(y)) is on the line x == y")case let (x, y) where x == -y: print("(\(x), \(y)) is on the line x == -y")case let (x, y): print("\(x), \(y) is just some arbitrary point")&#125; 7. 复合匹配当多个条件可以使用同一种方法来处理时，可以将这几种可能放在同一个case后面，并且用逗号隔开。 8. 控制转移语句8.1 Continuecontinue语句告诉一个循环体立刻停止本次循环，重新开始下次循环。 123456789101112let puzzleInput = "great minds think alike"var puzzleOutput = ""for character in puzzleInput.characters &#123; switch character &#123; case "a", "e", "i", "o", "u", " ": continue default: puzzleOutput.append(character) &#125;&#125;print(puzzleOutput)// 输出 "grtmndsthnklk" 8.2 Breakbreak语句会立刻结束整个循环体的执行。 8.3 贯穿Swift中的switch不会从上一个case分支落入到下一个case分支中。如果你需要C风格的贯穿特性，可以在每个需要该特性的case分支中使用fallthrough关键字。 1234567891011let integerToDescirbe = 5var description = "The number \(integerToDescirbe) is"switch integerToDescirbe &#123;case 2, 3, 5, 6, 11, 13, 17, 19: description += " a prime number, and also" fallthroughdefault: description += " an integer."&#125;print(description)// 输出 "The number 5 is a prime number, and also an integer." 8.4 提前退出条件为真时，执行guard语句后面的代码，不同于if语句，一个guard语句总是有一个else从句，如果条件不为真则执行else从句中的代码。 12345678910111213141516171819func greet(person: [String: String]) &#123; guard let name = person["name"] else &#123; return &#125; print("Hello \(name)") guard let location = person["location"] else &#123; print("I hope the weather is nice near you.") return &#125; print("I hope the weather is nice in \(location).")&#125;greet(person: ["name": "John"])// 输出 "Hello John!"// 输出 "I hope the weather is nice near you."greet(person: ["name": "Jane", "location": "Cupertino"])// 输出 "Hello Jane!"// 输出 "I hope the weather is nice in Cupertino." 8.5 检测API可用性12345if #available(iOS 10, macOS 10.12, *) &#123; // 在iOS使用iOS 10的API，在macOS使用macOS 10.12的API&#125; else &#123; // 使用先前版本的iOS和macOS的API&#125; 平台名字可以是iOS，macOS，watchOS和tvOS。]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的集合类型]]></title>
    <url>%2FSwift%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B.html</url>
    <content type="text"><![CDATA[Swift提供Arrays、Sets和Dictionaries三种基本的集合类型用来存储集合数据。 1. 数组数组使用有序列表存储同一类型的多个值，相同的值可以多次出现。 1.1 创建一个空数组1var someInts = [Int]() 1.2 创建一个带有默认值得数组12var threeDoubles = Array(repeating: 0.0, count: 3)// 等价于[0.0, 0,0, 0.0] 1.3 通过两个数组相加创建一个数组123var anotherThreeDoubles = Array(repeating: 2.5, count: 3)var sixDoubles = threeDoubles + anotherThreeDoubles// sixDoubles被推断为[Double] 1.4 用数组字面量构造数组12var shoppingList:[String] = ["Eggs", "Milk"]// shoppingList已经被构造并且拥有两个初始项 由于Swift的类型推断机制，当我们用字面量构造只拥有相同类型值数组的时候，可以省却数组的类型： 1var shoppingList = ["Eggs", "Milk"] 1.5 访问和修改数组 count：获取数组中的元素数目 isEmpty：检查count是否为0 append(_:)：在数组后面添加新的数据 insert(_:at:)：在某个具体索引值之前添加数据项 remove(at:)：移除数组中的某一项 removeLast()：移除数组的最后一项 +=运算符可以直接在数组后面添加一个或多个同类型的数据项： 12shoppingList += ["Baking Powder"]shoppingList += ["Chocolate Spread", "Cheese", "Butter"] 我们可以通过下标获取或改变某个已有索引值对应的数据。还可以利用下标来一次改变一系列的数据值：1shoppingList[4..&lt;6] = ["Bananas", "Apples"] 1.6 数组的遍历我们可以用for-in循环遍历所有数组中的数据项。如果我们同时需要每个数据项的值和索引值，可以使用enumerated()方法。enumerated()返回一个由每一个数据项索引值和数据值组成的元组： 123for (index, value) in shoppingList.enumerated() &#123; print("Item \(String(index + 1)): \(value)")&#125; 2. 集合集合用来存储相同类型并且没有确定顺序的值，集合内的元素不能重复。 2.1 集合类型的哈希值存储在集合中的类型必须是可哈希化的，Swift的所有基本类型（比如String,Int,Double和Bool）默认都是可哈希化的，没有关联值额枚举成员值默认也是可哈希化的。 你可以使用自定义的类型作为集合的值的类型或字典的键的类型，但需要使自定义类型符合Swift标准库中的Hashable协议。符合Hashable协议的类型需要提供一个类型为Int的可读属性hashValue。 2.2 集合类型语法2.2.1 创建和构造一个空的集合1var letters = Set&lt;Character&gt;() 2.2.2 用数组字面量创建集合1var favoriteGenres: Set&lt;String&gt; = ["Rock", "Classical", "Hip hop"] 2.2.3 访问和修改一个集合 count：返回Set中元素的数量 isEmpty：检查count是否为0 insert(_:)：添加一个新元素 remove(_:)：删除一个元素（如果Set不包含该值，返回nil) removeAll()：删除所有元素 contains(_:)：检查Set中是否包含一个特定的值 2.2.4 遍历一个集合使用for-in遍历一个集合。Swift的Set类型没有确定的顺序，为了按照特定的顺序来遍历一个Set中的值可以用sorted()方法，它将返回一个有序数组，这个数组的元素排列顺序又操作符&lt;对元素进行比较的结果来确定 。 1234for genre in favoriteGenres.sorted() &#123; print("genre")&#125;// 按顺序打印"Classical", "Hip hop", "Jazz" 2.3 集合操作2.3.1 基本集合操作 intersection(_:)：根据两个集合中都包含的值创建一个新的集合 symmetricDifference(_:)：根据在一个集合中但不在两个集合中的值创建一个新集合 union(_:)：根据两个集合的值创建一个新集合 subtracting(_:)：根据不在该集合中的值创建一个新集合 123456789101112131415let oddDigits: Set = [1, 3, 5, 7, 9]let evenDigits: Set = [0, 2, 4, 6, 8]let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]oddDigits.union(evenDigits).sorted()// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]oddDigits.intersection(evenDigits).sorted()// []oddDigits.subtracting(singleDigitPrimeNumbers).sorted()// [1, 9]oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()// [1, 2, 9] 2.3.2 集合成员关系和相等 ==：判断两个集合是否相等 isSubset(of:)：判断一个集合中的值是否也被包含在另一个集合中 isStrictSubset(of:)/isStrictSuperset(of:)：判断一个集合是否是另一个集合的子集合/父集合并且两个集合不相等 isDisjoint(with:)：判断那两个集合是否有交集 123456789101112let houseAnimals: Set = ["dog", "cat"]let farmAnimals: Set = ["cow", "chicken", "sheep", "dog", "cat"]let cityAnimals: Set = ["bird", "mouse"]houseAnimals.isSubset(of: farmAnimals)// truefarmAnimals.isSuperset(of: houseAnimals)// truefarmAnimals.isDisjoint(with: cityAnimals)// ture 3. 字典字典是一种存储多个相同类型的值得容器，字典中的数据项没有具体顺序。 3.1 创建一个空字典1var namesOfIntegers = [Int: String]() 3.2 用字典字面量创建字典1var airports: [String: String] = ["XYZ": "Toronto Pearson", "DUB": "Dublin"] 或 1var airports = ["XYZ": "Toronto Pearson", "DUB": "Dublin"] 3.3 访问和修改字典同数组和集合一样，字典同样具有count、isEmpty属性。我们可以在字典中使用下表语法添加新的数据项，或者改变特定键对应的值。 12airports["LHR"] = "London"airports["LHR"] = "London Heathrow" updateValue(_:forKey:)具有同样的功能，不同的是，这个方法返回更新值之前的原值，即对应值的类型的可选值。 1234if let oldValue = airports.updateValue("Dublin Airport", forKey: "DUB") &#123; print("The old value for DUB was \(oldValue)")&#125;// 输出 "The old value for DUB was Dublin 我们也可以使用下标语法在字典中检索特定键对应的值。 123456if let airportName = airports["DUB"] &#123; print("The name of the airports is \(airportName)")&#125; else &#123; print("That airport is not in the airports dictionary")&#125;// 打印 "The name of the airports is Dublin Airport" 我们还可以使用下标语法通过给某个键的对应值赋值为nil来从字典里移除一个键值对： 12airports["APL"] = "Apple Internation"airports["APL"] = nil removeValue(forKey:)方法也可以用来移除键值对，返回被移除的值或者在没有值得情况下返回nil： 123456if let removedValue = airports.removeValue(forKey: "DUB") &#123; print("The removed airports name is \(removedValue)")&#125; else &#123; print("The airports dictionary does not contain a value for DUB")&#125;// prints "The removed airports name is Dublin Airport" 3.4 字典遍历除了for-in玄幻遍历，我们也可以通过访问keys或者values属性，遍历字典的键或者值： Swift的字典类型是无序集合类型，为了以特定的顺序遍历字典的键或值，可以对字典的keys或values属性使用sorted()方法。]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的字符串和字符]]></title>
    <url>%2FSwift%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6.html</url>
    <content type="text"><![CDATA[1. 初始化空字符串123var emptyString = ""var anotherEmptyString = String()// 两个字符串均为空并等价 判断字符串是否为空： 123if emptyString.isEmpty &#123; print("Nothing to see here")&#125; 2. 字符串是值类型Swift中的String类型是值类型。如果你创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数/方法中传递时，会进行值拷贝。任何情况下，都会对已有字符串值创建新副本，并对该副本进行传递或赋值操作。 3. 访问和修改字符串3.1 字符串索引 Index：String.Index对应着字符串中每一个Character的位置 startIndex：可以获取一个String的第一个Character的索引 endIndex：最后一个Character的索引，非有效下标 index(before:)：前一个索引 index(after:)：后一个索引 index(_:offsetBy:)：对应偏移量的索引 indices：创建一个包含全部索引的范围（Range），用来在一个字符串中访问单个字符 3.2 插入和删除 insert(_:at:)：在一个字符串的指定索引插入一个字符 insert(contentsOf:at:)：在一个字符串的指定索引插入一段字符串 remove(at:)：在一个字符串的指定索引删除一个字符 removeSubrange(_:)：在一个字符串的指定索引删除一个子字符串 12345var welcome = "hello there!"welcome.remove(at: welcome.index(before: welcome.endIndex))let range = welcome.index(welcome.endIndex, offsetBy: -6)..&lt;welcome.endIndexwelcome.removeSubrange(range)// welcome 现在等于"hello" 3.3 比较字符串3.3.1 字符串/字符相等字符串/字符可以用操作符==和!=比较是否相等。 3.3.2 前缀/后缀相等hasPrefix(_:)和hasSuffix(_:)用来检查字符串是否拥有特定前缀/后缀。]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的断言]]></title>
    <url>%2FSwift%E4%B8%AD%E7%9A%84%E6%96%AD%E8%A8%80.html</url>
    <content type="text"><![CDATA[1. 断言1.1 使用断言进行调试12let age = -3assert(age &gt;= 0, "A person's age cannot be less than zero") age &gt;= 0为false，断言被触发，终止应用。 注意：当代码使用优化编译的时候，断言将会被禁用，例如在Xcode中，使用默认的target Release配置选项来build时，断言会被禁用。断言只会在 Debug 模式下起作用，在 Release 版本中是被忽略的。 1.2 何时使用断言当条件可能为假时使用断言，但是最终一定要保证条件为真，这样你的代码才能继续运行。断言的适用情景： 整数类型的下标索引被传入一个自定义小标实现，但是下标索引值可能太小或者太大 需要给函数传入一个值，但是非法的值可能导致函数不能正常执行 一个可选值现在是nil，但是后面的代码运行需要一个非nil值]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>断言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的可选类型]]></title>
    <url>%2FSwift%E4%B8%AD%E7%9A%84%E5%8F%AF%E9%80%89%E7%B1%BB%E5%9E%8B.html</url>
    <content type="text"><![CDATA[1、可选类型概念可选类型用来处理值可能缺失的情况。 下面的例子尝试将一个String转换成Int: 123let possibleNumber = "123let convertedNumber = Int(possibleNumber)// convertedNumber 被推测为类型"Int?" 可以给可选变量赋值为nil来表示它没有值： 12var serverResponseCode: Int? = 404serverResponseCode = nil 注意：nil不能用于非可选的常量和变量。如果代码中有常量或者变量需要处理值缺失的情况，应该声明称对应的可选类型。 如果声明一个可选常量或者变量但是没有赋值，它们会自动被设置为nil: 12var surveyAnswer: String?// surveyAnswer 被自动设置为nil 可选类型可以用 ?? 设置默认值：123var s: String?var s1 = s ?? "xx"print(s1) // print "xx" 注意：Swift中的nil和Objective-C中的nil不一样。在OC中，nil是一个指向不存在对象的指针。在Swift中，nil不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为nil，不只是对象类型。 2、强制解析当你确定可选类型确实包含值之后，可以在可选的名字后面加一个感叹号（!）来强制解析获取值。 123if convertedNumber != nil &#123; print("convertedNumber has an integer value of \(convertedNumber).")&#125; 3、可选绑定123456if let actualNumber = Int(possibleNumber) &#123; print("\'\(possibleNumber)\' has an integer value of \(actualNumber)")&#125; else &#123; print("\'\(possibleNumber)\' could not be converted to an integer")&#125;// 输出 "'123' has an integer value of 123" 如果Int(possibleNumber)返回的可选Int包含一个值，创建一个叫做actualNumber的新常量并将可选包含的值赋给它。 4、隐式解析可选类型有时候一个可选类型第一次被赋值后，可以确定它总会有值。在这种情况下，每次都要判断和解析可选值是非常低效的。 这种类型的可选状态被定义为隐式解析可选类型。把想要用作可选类型的后面的问号（String?）改成感叹号（String!）来声明一个隐式解析可选类型。 隐式解析可选类型主要被用在Swift中类的构造过程中，请自行查阅相关资料。 下面的例子展示了可选类型和隐式解析可选类型之间的却别： 1234567let possibleString: String? = "An optional string."let forcedString: String = possibleString!// 需要感叹号来获取值let assumedString: String! = "An implicitly unwrapped optional string."let implicitString: String = assumedString// 不需要感叹号 注意：如果一个变量之后可能变成nil的话不要使用隐式解析可选类型。如果需要在变量的声明周期中判断是否是nil的话，使用普通可选类型。 5. 可选类型的链式取值传统写法：1234567var display: UILabel?if let temp1 = display &#123; if let temp2 = temp1.text &#123; let x = temp2.hashValue ... &#125;&#125; 链式写法：12if let x = display?.text?.hashValue &#123;...&#125; // x is an Int let x = display?.text?.hashValue &#123;...&#125; // x is an Int]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>可选类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的元组]]></title>
    <url>%2FSwift%E4%B8%AD%E7%9A%84%E5%85%83%E7%BB%84.html</url>
    <content type="text"><![CDATA[元组把多个值组合成一个复合值，元组内的值可以是任意类型。 12let http404Eror = (404, "Not Found")// http404Error的类型是(Int, String) 元组的内容可以分解成单独的可使用的常量和变量： 123let (statusCode, statusMessage) = http404Errorprint("The status code is \(statusCode)")print("The status message is \(statusMessage)") 如果只需要分解一部分元组值，可以用_标记要忽略的部分： 12let (justTheStatusCode, _) = http404Errorprint("The status code is \(justTheStatusCode)") 此外，还可以通过下标来访问元组中的单个元素： 12print("The status code is \(http404Error.0)")print("The status code is \(http404Error.1)") 定制元组的时候可以给单个元素命名： 123let http200Status = (statusCode: 200, description: "OK")print("The status code is \(http200Status.statusCode)")print("The status message is \(http200Status.description)") 强烈推荐给元祖的元素命名，可以使代码更清晰。 作为函数返回值时，元组非常有用: 123456789func getSize() -&gt; (statusCode: Int, description: String) &#123; return (200, "OK")&#125;let x = getSize()print("code is \(x.statusCode), descripiton is \(x.description)")// orprint("code is \(getSize().statusCode), descripiton is \(getSize().description)")// print "code is 200, descripiton is OK" 注意：元组在临时组织值得时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体。]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>元组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《活在当下》摘录]]></title>
    <url>%2F%E3%80%8A%E6%B4%BB%E5%9C%A8%E5%BD%93%E4%B8%8B%E3%80%8B%E6%91%98%E5%BD%95.html</url>
    <content type="text"><![CDATA[这本书写的朴实无华，基本都是作者本人的一些亲身经历和感受，恰是那份真实，直击我心，给了我莫大的启发和帮助。 读至精彩处，如醍醐灌顶，读罢全书，却无法书写读完的感受。可能我阅历尚浅，不足以描述它给我带来的潜移默化的触动。 我相信以后我还会再来翻看它的，不同的阶段，常看常新。既然无法成文，先作点摘录如下。 生命其实可以被看做一种物质，它是以时间为单位的。我们大部分人的生命长度看似相近，但是在这相近数量的生命里，我们能够萃取的精华却是大相径庭。生命的宽度与高度完全取决于我们以什么样的态度和方式去生活。我们每天把各种食物以最快的速度塞进嘴里，同时可能还在闲谈、思考事情或是看电视。这样不但对食物的味道没有什么感觉，甚至还会影响消化。我们以同样的态度和方式对待我们的生命，沉浸在对过去的回忆中，执着于对未来的幻想中，我们看起来在历经生命的过程，实际上却错过了它。结果不仅人生索然无味，而且身心问题一大堆。 许多灵修体系的精髓其实就是一个片刻接一个片刻地活在当下，全身心专注地生活。这样的生活，几近于道。世界闻名的越南高僧一行禅师，一本深具启发的书《一步一莲花》，在书中写道： 生命的意义只能从当下去寻找 逝者已矣，来者不可追 如果我们不反求当下 就永远探触不到生命的脉动 最有效的自我发掘过程，始终是先静默，并倾听静默，然后写下我所听到的，而所有透过我的笔端刻书在纸上的文字，我总是第一个受益者。 真实刹那的另一个说法是“全神贯注”。全神贯注是东方许多的传统思想之一，特别是佛教的核心概念。简言之，就是讲全副心神贯注在眼前手边的事物上，让心灵毫无杂念地去体验当下。 他说麻木生活和行动的人，一不小心就会坠入行尸走肉的泥沼里。我们顺着时间走下去，眼光却不看着当下，只着意于未来，之后则怀疑，为什么不曾走到任何能给自己有持久成就感的目的地。 整个20世纪的后半段，我们都在为明天而活，对当下所付出的时间则少之又少，我们为未来计划、为未来担忧，然后不知不觉中，当生命走到了尽头才醒悟：我们一心一意计较已发生或希望到来的事，却忘了享受当下的每一个片刻；我们都变成“为生活而做准备”的专家，同时也变成“现在就充分享受活着”的低能儿；我们为事业做准备，为休假做准备，为周末做准备，为退休而准备——总括起来，我们其实是在为了生命终了做准备。 快乐与满意的差别在哪里？满意基本上是一种精神上的满足，它代表完成了某件你有所为而为的事——一项计划、一次交谈、一顿美食。比如，新书的进度又完成了一章，我会觉得很满意；发表了一场演说而且颇受好评，我会觉得满意；把柜子清理干净，我也会觉得很满意；总之就是有某件事情完成了。 快乐则比较倾向情绪方面的满足。当我在某本书的某一章里，写出了自己都叹为观止的语句，我会觉得很快乐；演讲后，有人前来和我分享感触，我深有同感，会觉得很快乐；我望着衣橱里的某件衣服，回想起曾经穿着它度过的一个有趣的夜晚，我会觉得很快乐。 快乐只存在于每一个刹那的当下，也只在当下可得。快乐降临的那一刹那，绝不会是我们存心去找寻快乐的时候，因为一旦存心追求，我们的心就已不在“此时此地”，而是到“别处”去了。如果我们能让自己回到现在，全神贯注于手边的事物，快乐便会不求自来。“快乐”（happiness）这个词源自古英语里的“hap”，指机会或运气（不论好坏）——意思就是人的遭遇（happens）。换句话说，照词源上的解释，“快乐”应该是“所有当下的经历”。所以尽管我们会说“我要快乐起来”，基本上我们已经把自己投射到未来去了；而快乐，依照定义，是只存于当下的这一刻。 你也曾是个快乐的高手——在你还是个孩子的时候。儿童是创造快乐的专家，他们还没有学会按捺住心中的欢欣，所以可以尽情尽兴！ 英文present具有双重意义，可指此时此刻的现在，也指礼物或赠与物。 如果我们想求得内心真正的平静与纯真，我们必须面对一个事实——所有的痛苦、悲伤、不愉快，都是生命时常出现、不可或缺的一部分。我们不可能永远快乐，心理学家荣格这么说过：有多少个白天，就有多少个黑夜，一生之中，黑夜与白天所占的时间一样长，没有黑暗就显不出欢乐时刻的光明；失去了悲伤，快乐也就无由存在了。 在我们能与对方异地而处之前，永远不要批评。 希望我能帮你找到一直潜藏在你心中，你却避而不见的情感和力量。也希望我能为你剥开经年累月积下的层层不经心与不在意，好让你想起此生存在的真正意义。 活着的时候，最好能记住：死亡即将来到，而我们不知道它降临的确切时间。这能让我们随时保持警觉，提醒我们趁着机会还在，要尽情地活着。是该有人常常告诉我们：来日无多。然后我们才可能将生命中的每一天、每一分、每一秒发挥到极致。不论你想做什么，现在就去做吧！明日复明日，明日何其多……]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>活在当下</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊【折腾】的重要性]]></title>
    <url>%2F%E8%81%8A%E8%81%8A%E3%80%90%E6%8A%98%E8%85%BE%E3%80%91%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7.html</url>
    <content type="text"><![CDATA[本文转载于：https://program-think.blogspot.com/2017/04/The-Importance-of-Zheteng.html 引子前不久写了篇关于 Linux 的博文。看到博客评论区中有一些“关于折腾的抱怨”。之前俺写其它教程（比如：翻墙、操作系统虚拟机），也看到过类似的抱怨。 关于折腾的抱怨，俺总结下来有两类： 其一，“从不折腾的人”抱怨折腾太麻烦（这类抱怨往往是泛泛的） 其二，“有过折腾经历的人”抱怨折腾太麻烦（这类抱怨往往是有具体所指的） 所以今天就来聊聊“折腾”这个话题。 名词定义：何为“折腾”为了避免某些人抬杠，先界定一下关键术语——“折腾”一词指的是啥？ 在下面的讨论中，“折腾”一词指的是： 在你【不熟悉】的领域中干某些事情（如果是你【熟悉】的领域，那属于“轻车熟路”，不能算“折腾”） 这些事情通常带有某种“探索/钻研”的性质（通常颇费周折） 这些事情通常要耗费一定的时间和精力（能很快搞定的，就不能算“折腾”） 这些事情通常具有不确定的结果（你不清楚是否能得到期望的结果）。 举例： 针对软件的折腾（比如：Linux） 针对硬件的折腾（比如：树莓派） 针对网络的折腾（比如：翻墙） …… “折腾”与“自学能力”◇“自学能力”的重要性 博客的读者们应该都明白这玩意儿的重要性吧？俺随便说几点： 比如：信息时代会有很多新生事物。你以前在学校课堂里学到的知识/技能已经无法应对这些新生事务，你需要通过自学来搞定它们。 比如：在信息时代，知识的半衰期会变短。你以前在学校课堂里学到的知识/技能，等到你工作时，有些已经过时（失效）了。你需要通过自学来更新这部分过时的知识。 比如：如今的职场竞争会比以往更激烈（信息流动加快使得人才流动加快）。自学能力强的人无疑会有更大的优势。 …… ◇两者的关系 前面俺强调了：折腾的前提是——在你【不熟悉】的领域。 在这种领域中，你多半要通过自学，掌握某些知识或技能，让“不熟悉的领域”变为“熟悉的领域”。 所以，喜欢折腾的人，他/她的自学能力会经常得到锻炼。 当然啦，“经常锻炼自学能力”不一定就表示“自学能力很强”，但至少好于那些“从来没有得到锻炼的人”。 “折腾”与“解决问题能力”◇“解决问题能力”的重要性 说到这个，俺又要趁机来恶毒攻击一下咱们天朝的教育体制了 :) 如果你回顾一下学校（小学/中学/大学）里面的考试或课后作业，大部分的题目都有标准答案（理工科尤其明显）。 但是当你进入职场后，很多工作中的问题，其解决方法是多种多样的，【没有标准答案】。 这两类问题的解题思路是完全不同滴—— 【有】标准答案的问题，解题的思维过程通常是【收敛式】； 【没有】标准答案的问题，解体的思维过程通常是【发散式】。 有很多学校中的优秀生，他们很擅长于考试，但是在工作中的表现却令人难以恭维。因为他们擅长的【收敛式思维】，在工作中通常用不上。 ◇两者的关系 “折腾”与“解题能力”有哪些关系捏？ 当你在不熟悉的领域中折腾，通常不会一帆风顺——整个过程必然会碰到各种各样的问题（困难和障碍），这些问题往往是没有标准答案滴。换句话说，折腾中碰到问题，【不同于】你在学校中碰到的考题，而【更接近于】你在实际工作中碰到问题。 所以，经常折腾的人，会有更多的机会去锻炼他/她的【发散思维能力】。也就可以更多地弥补学校教育在这方面的缺陷。 “折腾”与“知识面/知识结构”◇知识面的重要性 如今这个信息时代，【复合型人才】更有竞争优势。所谓的“复合型”，其主要特征【之一】就是“知识面比较广”。这类人往往兼具多个不同领域的技能。 就拿自己来现身说法——简述一下：维护目前这个博客，大概需要哪些技能？ 基本的写作能力是必不可少滴——如果写出来的文章狗屁不通，就没人看了； 翻墙是必不可少滴——俺必须把博客搭建在墙外，才能防止真理部的和谐； 信息安全也是必不可少滴——否则早就被跨省追捕了； 懂一些 Web 开发的技能（CSS 和 JS）是有好处滴——有助于俺把博客界面搞得好看/好用； 除了上面这些，因为俺博客聊到了“政治、历史、心理学、管理、编程”这几类话题，所以俺在这几个领域多少还算略懂（不敢妄称精通）。 ◇什么样的知识结构才是合理的（有优势的） 前面提到了“知识面的广度”。但仅仅有广度是【不够】滴。良好的知识结构，应该兼具【广度】与【深度】。 至于“深度”与“广度”要如何搭配才比较好，可以看俺多年前的一篇博文《如何完善自己的知识结构》。 ◇两者的关系 那么，“折腾”与“知识面/知识结构”有啥关系捏？ 比如说：你正在折腾 A领域 的某个事物，在折腾的过程中可能会依赖到相关领域的知识（比如说 B领域 和 C领域）。而 B领域 和 C领域 可能是你之前所不了解的。为了搞定 A领域，你就需要顺便去了解 B领域 和 C领域。无形中，你的知识面就拓宽了。 举个栗子： 某个技术菜鸟去折腾翻墙，当此人搞定之后，通常也顺便学会了一些网络相关的知识（比如：代理、VPN …） 如果此人是通过 VPS 来搭建翻墙代理，说不定还顺便学会了一些 Linux 系统管理方面的知识。 “折腾”与“动手实践能力”◇两种不同的领域 所有的领域可以分为两类——“记忆型”与“实践型”。 （注：这两个术语是俺拍脑袋临时起的名儿，如果你有更恰当的叫法，欢迎告知俺） 所谓的“记忆型”，意思就是说：你只需要依靠记忆力就可以掌握该领域。 而“实践型”则完全不同——要掌握这种类型的领域，光靠记忆力是肯定不够滴，一定要经过动手实践。 举例： “记忆型”的例子比较少：历史、艺术鉴赏… “实践型”的例子比较多：所有的体育项目、所有的棋牌游戏和电子游戏、烹调、编程、管理、艺术创作…… 对于“实践型”的领域，不管你看了多少相关的书籍，记住了多少相关的知识，最后都要经过实践，才能最终掌握该领域。套用一句古话就是：纸上得来终觉浅，绝知此事要躬行。 举例： 比如说下围棋——如果某人从来没有实际下过，即使此人看了 N 多的棋谱，看了 N 多的围棋理论书籍，也不能算是“会下棋”。 学编程也类似——俺一直强调学编程（尤其是新人学编程）要：一边看书一边动手写点小程序练手。 ◇两者的关系 俺个人认为：凡是需要折腾的领域，都是实践型的领域。 而经常折腾的好处在于：每次折腾都是在锻炼你的动手实践能力。 “折腾”与“心理舒适区”◇啥是“心理舒适区”？ 两年前（2015）写过一篇《什么是【真正的】兴趣爱好？以及它有啥好处？》，其中正好聊过“心理舒适区”这个概念。下面这段直接引用那篇博文。 首先来解释一下，何为“心理舒适区”。这玩意儿，洋文称之为“Comfort Zone”，用来描述一种“心理状态”。处于这种状态，你会感觉到放松，没有压力和焦虑。 如果你处于某个环境中，在该环境下所需要的行为你都可以轻松搞定。那么，你就处于“心理舒适区”。 举例： 上网闲逛 看电视剧 看娱乐节目 ◇“走出心理舒适区”的重要性 几乎所有的个人能力，如果要想得到提升，都需要你跳出“心理舒适区”。 比如说那些优秀的体操运动员，他们需要不断练习自己【不熟悉】的动作，这样才能提高；反之，如果某个体操运动员总是练习自己最拿手的动作，那是没有长进的（或者说，长进非常有限）。 ◇为啥大部分人都【无法】走出心理舒适区？ 首先，人都是惰性的。 停留在心理舒适区，极大地满足了人的惰性。 要离开心理舒适区，就要克服这种惰性；这通常需要动用意志力，而且需要一定的技巧。 大多数人的意志力是偏弱的；即使是少数意志力较强的人，其中还有一定比例是缺乏运用技巧的。 如果你对这个结论有所怀疑，不妨去观察一下：大部分人在闲暇时间都在干嘛。你就会发现：大部分人都在用一些【轻松的/消遣性的/娱乐性的】活动来打发时光。 ◇两者的关系 前面说过：折腾的往往是自己不熟悉的领域，所以折腾的过程往往会碰到一些障碍和困难。 而搞定这些障碍和困难，通常需要你跳到“心理舒适区”【之外】。 所以，经常折腾的人，就经常需要挑战困难和障碍，于是也就有更多机会去练习——如何跳出心理舒适区。 聊聊那些“不折腾”的理由或借口说完了“心理舒适区”，顺便列几个反面教材——关于“不折腾的理由或借口”。 常见的理由/借口有如下几种： ◇抱怨“无用功” 很多人觉得：如果折腾某个东西，最后没有搞出来（失败了），那就白白浪费了时间，成为“无用功”。 这个理由非常有迷惑性（尤其是在天朝这个功利主义非常盛行的社会）。 实际情况是：即使你折腾某个东西最后失败了，也【不会】是无用功。 因为在这个过程中，你会有很多收获——包括前面提到的几种能力提升和知识面的拓展。 ◇抱怨“时间不够” 这可能是最常见的一种抱怨（借口）——说自己工作太忙，没有空闲的时间去折腾其它东西。 首先，拿网上流传的一句话来反驳此借口——时间就像乳沟，只要你愿意挤，总是有的。 然后，来分析一下俺博客的读者群，应该大部分是学生或者白领/蓝领。 对于在校的学生 （不管是大学生还是中学生）肯定是是有闲暇时间的（比如寒暑假）。 即使是高三年很忙，只要等高考结束，之后那个假期总归是空闲的。 对于工作中的上班族 很多人抱怨“加班”占用时间。 试问：有多少公司是一年365天，天天都加班（完全没有周末和节假日）；而且每天（无一例外）都加班到深夜，一回家就上床睡觉，然后一觉醒来就又去上班。这样的公司，就算有，占总体的比例肯定也是微乎其微的。 还有一些人抱怨“养小孩”占用时间。 这种借口同样是站不住脚滴。“养小孩”确实会占用一些业余时间，但比例肯定达不到100%；而且特别占时间的，通常是小孩刚出生的开头三五年。 所以，绝大部分上班族肯定是有闲暇时间的。 ◇抱怨“精力不够” 另一种常见的抱怨是：上班已经很累，下班回家哪还有精力去折腾其它东西。 首先，很多人发这种抱怨是有夸大其辞的嫌疑。 其次，退一步讲，就算有【少数工作】是每天都很累以至于每天下班回家都精疲力竭。但你至少还有周末的双休日可用啊。每年有52个星期，单算双休日就有一百多天呢！（这还没算上国定假日） ◇抱怨“技能不够” 有这种抱怨的人，要么是找借口，要么是太缺乏自信。 在如今这个互联网很普及的时代（天朝网民据说已经6亿或7亿了），很多需要折腾的事物，都可以在网上找到教程，甚至是手把手的傻瓜教程。有了教程（尤其是傻瓜教程），折腾的门槛已经大大降低了。 （至于如何在网上找到教程，可以参考《如何挖掘网络资源》系列博文） 当然啦，即使有了再完备的教程，你依然会在折腾的过程中碰到一些困难和障碍。所以“教程的存在”并【不会】影响你锻炼“解决问题的能力”。 ◇小结 上述所有这些，如果是【理由】的话，那都是不成立的；如果是【借口】的话，那都可以归咎于——不愿意离开心理舒适区。 为啥很多人都在找借口捏？因为大部分人【不】愿意承认：自己总是停留在心理舒适区；并且大部分人更【不】愿意承认：自己无法离开心理舒适区。所以，他们需要找各种借口来掩饰。 俺写本文的目的在本文最后，稍微透露一下俺写本文的动机。 可能大多数读者会【误以为】：俺写这篇是想劝那些不喜欢折腾的人改变习惯，多多折腾。 NO，NO，NO！这不是俺的本意。 前面说了：那些不喜欢折腾的人，无法（难以）跳出心理舒适区。这是由他们的本性（意志力、观念、性格 …）决定的。而一个人的本性，是【无法】轻易改变滴。所以，俺当然【不指望】：靠这样一篇短短的博文，就能改变他们的本性。 那俺为啥还要写这篇博文捏？写此文的目的是：鼓励那些已经走上折腾之路的同学们，希望他们能在这条路上走得足够远。【好好折腾，天天向上】]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017斯诺克世锦赛记忆]]></title>
    <url>%2F2017%E6%96%AF%E8%AF%BA%E5%85%8B%E4%B8%96%E9%94%A6%E8%B5%9B%E8%AE%B0%E5%BF%86.html</url>
    <content type="text"><![CDATA[年度收官之战，落下帷幕，塞尔比卫冕成功，一战封神，继续稳坐世界第一宝座。此役之后，塞尔比成为继戴维斯、亨得利、奥沙利文之后，成功在克鲁斯堡卫冕的第四人。单赛季5座排名赛奖杯，单赛季将“75三杰”各个击败，四年内将第三座世锦赛奖杯收入囊中，排名赛冠军增至12个，塞尔比成为了无可争议的80后第一人。在“75三杰”宝刀未老而80后青黄不接的时代，众议塞尔比扛过大旗，开启了新王朝。我之前也写过一篇文章，讨论这会不会是塞尔比的王者时代，我尊重他的坚韧和成就，但欣赏不了他的打法，说真的，我很难坚持看完他的比赛。关于未来，不作预测，只是希望斯诺克发展的越来越好。 趁着记忆尚未褪去，拣一些印象比较深刻的片段记录一下。 一、克鲁斯堡40周年 今年的世锦赛比较特别，正好是世锦赛落户谢菲尔德的克鲁斯堡剧院40周年。为此，主办方举办了别开生面的绿毯秀。在随后的节目中，巴里·赫恩宣布世锦赛继续保留在克鲁斯堡至少十年。 自1977年以来，克鲁斯堡见证了雷·里尔顿、戴维斯、“飓风”希金斯、亨得利、火箭等伟大球员的辉煌时代。如今克鲁斯堡已经成为斯诺克世锦赛的代名词。它是无需声明的地标，是无数球员向往的圣殿。 二、中国军团崛起 本次世锦赛，中国军团的人数达到历史性的6位。可惜的是，中国军团的签位不太好，全都在同一个区。 傅家俊第一轮对阵卢卡的时候，在2-7落后的情况下反打卢卡8-2，实现超级大逆转。不得不说，Fu的心理是十分强大的。16进8的时候，Fu对阵萝卜，8-10落后的情况下实现反超，最后赢得了比赛。此时的Fu还是很平静的，看上去波澜不惊。他信佛，一生儒雅，给人的感觉从来都是很绅士，内心如水，他的心态应该算是中国军团里最好的。Fu的状态并不是最好的，可是依然削掉了萝卜。萝卜本是80后五虎里的领军人物，可是这两年开始走下坡路了，都是网瘾所致，这就是玩物丧志的典型。好在浪子回头，萝卜已经戒掉了网瘾，开始恢复正常的生活和训练。Fu赢了萝卜后，隔天就对阵小丑。明显看得出来他很疲惫，小丑状态未到最佳，却依然对Fu进行了大屠杀。 颜丙涛看上去比较成熟，完全看不出他是00后。目前看来，球风稳健，心理过硬。可能是出生牛犊不怕虎吧，进攻起来绝不手软。本次表现也很抢眼，在5-9落后的情况下，追到8-9。墨菲号称稳定先生，在颜丙涛的攻势下，墨菲压力很大，稳定先生也变得不稳定了。若不是Frame18关键球的时候，墨菲的晕袋终结了颜丙涛的世锦赛之旅，决胜局可能就是颜丙涛拿下了。 三、惊天大冷门 第一轮还有个惊天大冷门，总统特朗普被小黑哥（麦克劳德）逆转了，这是谁都没有想到的结果。可能特朗普确实有伤在身，他自己也不会想到会是这样的结果。小黑哥不给你按套路出牌，就是准，直接把总统准死了。当年以“准神”出道的总统，心里估计不好受。麦克劳德第二轮对阵马奎尔的时候，毫无还手之力，这是情理之中的事。床铺君这次真的是太大意了，本来还是夺冠热门，却惨遭一轮游。 四、丁俊晖心态更成熟 丁丁在中国德比胜了梁文博，成功会师“丁奥会”。这场比赛，应该是本届世锦赛观看人数最多的一场了。丁丁上次赢火箭，还是十一年前了。如今终于再次打败火老师，成功晋级四强。这场比赛我看了，中途却一度转台至巫师-艾伦的直播现场。我有点看不下去，因为那可能根本不是真实的火老师，我还是觉得火老师有放水嫌疑。火老师也没有让观众失望，又一次奉上了一杆任性的146。当时打到台面还剩几颗红球的时候，他开始笑了，那时候我就知道他又要故意打146了。147对他来说，已经没有多大的意义了，输赢也没那么重要，他现在很享受比赛和生活。火老师的这杆146，也是斯诺克世锦赛历史上第三杆146。也许他不想和塞尔比打吧，还能给丁丁一个助攻，火老师的2017世锦赛之旅到此结束。丁丁赢下比赛后，和火箭拥抱，两人交谈了一番，至于说了什么，我很想知道却无法得知，火老师还上前亲吻了丁丁，这一幕令人动容。十年前的温布利大师赛决赛现场，火箭人气太高，丁丁忍受不了现场球迷的谩骂和惨淡的比赛结果而泪洒现场，火箭上前安慰和鼓励。十年后，丁丁战胜了火箭，火箭上前拥抱和祝贺。 半决赛Frame32，丁丁进攻蓝球中袋出现简单的致命失误。塞尔比稳扎稳打，超分后狠狠地砸向球桌，伴随着猩猩般的怒吼。其实看得出来塞尔比压力也很大，他需要释放。丁丁和格里菲斯合作后，明显变得比以前成熟了。从赛后的数据统计来看，丁丁是全面压制塞尔比的，可是却输了。说明塞尔比在关键球的处理和稳定性上略胜一筹，丁丁可以通过这场比赛更好地对症下药，提升自己。相信经过此次世锦赛的洗礼，丁丁会变得更好更强大。此次未能夺冠，有点小遗憾，也许是时候未到。 五、祝贺小丑，心疼巫师 巫师和火箭同属75年，却已经谢顶，头发都白了。42岁的火老师鬓角也花白了，可能斯诺克确实是比较耗精力和脑力的一项运动，别看它没那么大运动量。69年出生的皇帝也是个例子，还不到50就头发胡子白了一大片，身体也发福了，当年可是颜值担当啊。巫师已经不是当年那个清秀的可爱大男孩了，如今可谓之希胖。 巫师虽然年岁已高，却宝刀未老。本届世锦赛，巫师的长台依然犀利，围球还是宗师级别水准，一个字：稳。16进8对阵火力凶猛的小钢炮艾伦，巫师游刃有余地化解了这股火力，多次单局逆转。钢炮直接哑火，巫师好好地给艾伦上了一课。1/4决赛，直接给了90后新星威尔逊一记闷棍，威尔逊都没有多少机会展开进攻。半决赛，轻取霍师傅。这么多年了，巫师不管遇到什么白马黑马，都可以打成死马，我好想把他的出场音乐换成陈奕迅的“打回原形”。 巫师在半决赛第三阶段直接一杆破百拿下霍师傅，赢得了宝贵的休息时间。而塞尔比和丁俊晖的对抗，消耗了他太多的精力。巫师以逸待劳，第一阶段6-2塞尔比，第二阶段一度将优势扩大到10-4，简直就是吊打塞尔比，期间还轰出一杆141平了火老师的决赛单杆最高分。塞尔比全场被压制，攻守俱劣。 S2F14，巫师一个四传，一个两传，拿下本局。截至此时，巫师本届世锦赛的表现都堪称梦幻，接下来，你知道我要说什么了。。。巫师的传球局好像把塞尔比惊醒了，他好像又会打球了，连下三局，将差距缩小到7-10。第三阶段的进程很慢，希胖表现不佳，精力也下降不少。第四阶段希胖明显体力不支，塞尔比将比分反超至16-12，希胖也没有紧张，连追三局将比分拉近到15-16，而塞尔比拼下一局后率先拿到赛点。最后一局，希胖心态可能确实有波动，出现致命的防守失误，最终比分定格在18-15。 十年前的世锦赛决赛，巫师称王克鲁斯堡。十年后，小丑制霸克鲁斯堡。 巫师42岁了，世锦赛决赛最年长的选手。我们的巫师老了，他喜欢喝酒，常常给人“上课”，笑起来就是个大男孩，球技依然是宗师水准，可敌不过时光，岁月从来不会偏袒谁，有限的生命里，我们更要及时留下更多值得的纪念。 输掉比赛后，一脸疲态的希胖不失风度，上前拥抱塞尔比，祝贺他夺冠。 祝贺小丑，心疼巫师！ 六、结语 有球员抱怨塞尔比是大魔王，他功利性的打法正在毁灭斯诺克，阻碍了斯诺克的发展。关于这一点，我是认同的。我还抱有的一点希望就是，也许时代需要这样的一类人，正是这些“阻碍”促进了进步，新的时代正在孕育，谁知道呢？ 斯诺克的本意就是障碍，只有成功escape那些障碍的人，才能成为最后的赢家。人生的道路上，正是那些障碍教会了我们如何去生活，我们才能成长地更坚强更美好。 最后，奉上巫师的决赛单杆最高分141，Enjoy it~]]></content>
      <categories>
        <category>snooker</category>
      </categories>
      <tags>
        <tag>snooker</tag>
        <tag>塞尔比</tag>
        <tag>世锦赛</tag>
        <tag>希金斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【人物】塞尔比的王者时代]]></title>
    <url>%2F%E3%80%90%E4%BA%BA%E7%89%A9%E3%80%91%E5%A1%9E%E5%B0%94%E6%AF%94%E7%9A%84%E7%8E%8B%E8%80%85%E6%97%B6%E4%BB%A3.html</url>
    <content type="text"><![CDATA[1999年，16岁的塞尔比转为职业球员。直到2008年，他才拿到第一个排名赛冠军。 截至今日，塞尔比已经将11座排名赛冠军奖杯收入囊中。仅从数量上看，这算不上顶尖表现。同时代的80后球员中，丁俊晖（87年）和罗伯逊（82年）都拥有12座排名赛冠军，塞尔比略逊一筹。但是从奖杯的含金量来看，塞尔比拔得头筹。 塞尔比的11个排名赛冠军中，有2个世锦赛冠军、2个英锦赛冠军、2个大师赛冠军，“三大赛”冠军就占据了7席，是80后球员中第一个完成两轮大满贯的。 很多人不喜欢塞尔比，我也没那么喜欢。不是讨厌，只是没法像喜欢火箭那样欣赏他。他早年的打法确实十分磨人，现在没那么磨人了，却依然打得十分聪明。巫师打火箭的秘诀就是压制他的节奏，我想塞尔比可能是在效仿巫师，效果还不错。14年，塞尔比在决赛阻止了火箭世锦赛三连冠的伟业。16年，他又破了火箭英锦赛决赛100%胜率的不败金身。 也有很多人喜欢他，因为他攻守兼备、打法睿智。我们喜欢与不喜欢一个人，靠的是“臭味相投”，从深层里说，是价值观上的认同感。 一个球手的打球风格，完全就是他本人性格的写照。如果一个人球风快而利落，他该是个爽快之人。如果一个人的球风慢而严谨，他该是个耐心的人。而一个人的性格，是他生活的淬炼。 塞尔比8岁母亲离家出走，16岁父亲因癌症离世，一个孤儿靠着救济过活。同年，在悲恸中的塞尔比转为职业球员。19岁，他就和一位比自己大的女子步入婚姻殿堂，他内心应该是十分渴望母爱和家庭的。不过这段关系只维持了短暂的时间，直到23岁，他才遇到了现在的妻子维基。塞尔比坦言，维基是他生命中最重要的基石，没有维基就没有今天的他。塞尔比早年的悲惨经历，正是塑造他性格的源头。若不是经历了磨难，我们怎么会看到今天认真、冷静、严谨和坚韧的“逆转王”。在严谨的斯诺克赛场上，他很会排解压力和活跃气氛，经常开玩笑和与观众互动，大家给他起了个绰号——莱斯特小丑。 塞尔比算不上天才少年，但是他的勤奋和认真，修来了大器晚成，如今可谓全面开花。16-17赛季已然接近尾声，塞尔比本赛季已经拿下了4个排名赛冠军，不可谓不强大。剩下的最重要的世锦赛，我们仍有可期。 如今群雄逐鹿的斯诺克界，塞尔比能否铸就他的王者时代？ 他的矛锋利无比，他的盾固若金汤，他的心异常坚韧，他是莱斯特小丑——马克·塞尔比。 下面请欣赏塞尔比的攻防艺术，Enjoy it~]]></content>
      <categories>
        <category>snooker</category>
      </categories>
      <tags>
        <tag>snooker</tag>
        <tag>塞尔比</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ShowTime】斯蒂芬·李劳斯莱斯级别的杆法秀]]></title>
    <url>%2F%E3%80%90ShowTime%E3%80%91%E6%96%AF%E8%92%82%E8%8A%AC%C2%B7%E6%9D%8E%E5%8A%B3%E6%96%AF%E8%8E%B1%E6%96%AF%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9D%86%E6%B3%95%E7%A7%80.html</url>
    <content type="text"><![CDATA[身高177cm，体重100+公斤，斯蒂芬·李是个胖子，人称胖子李。 好像在哪里看过，胖子李和火箭曾师承同门，两个人的发力都是柔中带刚。他对球的理解和表演欲，我认为和火箭是不相伯仲的。 他用的是枫木杆，可以在赛场上给白球施加魔法，让观众瞠目结舌。 他打假球，被判12年禁赛，这是他给自己做的一杆无解的“斯诺克”。 关于假球，很难界定。斯诺克是最容易作假最难被发现的运动之一，打假球的肯定不止胖子李一人。很可惜，他被杀了。 当初我看到下面这一杆的时候，有种惊为天人的感觉： 可惜我们再也看不到了，好在我们曾经见过神的模样。 【视频】斯蒂芬李劳斯莱斯级别的杆法秀:]]></content>
      <categories>
        <category>snooker</category>
      </categories>
      <tags>
        <tag>snooker</tag>
        <tag>斯蒂芬·李</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《成为乔布斯》]]></title>
    <url>%2F%E8%AF%BB%E3%80%8A%E6%88%90%E4%B8%BA%E4%B9%94%E5%B8%83%E6%96%AF%E3%80%8B.html</url>
    <content type="text"><![CDATA[乔布斯去世后，关于他的报道、传记和电影等层出不穷，我都没有读过或看过。偶尔看到一些关于他的片段，对他的总体印象就是：牛逼、偏执、有点渣。 今年看到《成为乔布斯》出版，外界评价颇高，去亚马逊买了电子书。很快就看完了2/3，很期待看到iPhone的问世，同时竟然有些舍不得看完，断断续续地看完了剩下的章节。自此，乔布斯在我心里才算有了一个较为清晰的轮廓。他是个天才，审美独特，创意非凡，富有人格魅力，他也是个普通人，热爱家庭，内心充满温暖。 我一直认为，iPhone4是苹果最辉煌的产品。乔布斯去世后，苹果依然在成功的轨道上滑行，却少了一份“惊艳”。 iPhone的问世，是乔布斯多年工作经验和人生阅历的沉淀。纵观苹果的各个产品，都有它符合时代潮流却又卓尔不群的特质，不同产品的内在又有相同之处，它们都归一于苹果精神。精神这种东西，很难概括，它呈现的具体而又独特，本身却抽象而宽泛。在我看来，苹果精神里分量最重的就是那句著名的Think different。而每个人的外在，反应的都是他的内在，Think different必然也是乔布斯内在灵魂里非常重要的特质。 时势造英雄，就算没有乔布斯，也会有someone改变世界，但不是乔布斯那样。很可惜，我们没能看到乔布斯3.0的时代，他更深厚的内在精神再也不能通过伟大的产品传递给我们。 没有人可以成为乔布斯，谁都可以改变世界，但乔布斯只有一个。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>乔布斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何提升行动力：人类行动心理学的有效Hack]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E8%A1%8C%E5%8A%A8%E5%8A%9B%EF%BC%9A%E4%BA%BA%E7%B1%BB%E8%A1%8C%E5%8A%A8%E5%BF%83%E7%90%86%E5%AD%A6%E7%9A%84%E6%9C%89%E6%95%88Hack.html</url>
    <content type="text"><![CDATA[人為什麼會拖延、人為什麼行動力很差。近些年心理學已經取得了突破性研究成果。普通人思考目標的時候，使用的是目標意圖, 是： 我要做什麼… 但是，有位天才心理學家Peter Gollwitzer發現目標意圖這樣的思考範式，反而很難達成目標，於是，他對自己的實驗對象，使用了一種替代範式。強迫實驗對象，使用一種稱之為：執行意圖的思考範式來思考。結果令人驚訝，人們更容易克服拖延症、達成目標。 什麼是執行意圖？就是使用if…then…的思考範式。比如， 不要再說，我要學Ruby。 而是說，如果我要學習Ruby，那麼，今天晚上就裝上環境。 當你關於行動與目標，長年累月這麼思考，最終建立自動化機制，那麼行動力慢慢就變強大了。如果…那麼…成為生命中的一部分。我要…這種句式，就從自己的語言體系中死掉了。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乔布斯2005斯坦福大学演讲中英文全文]]></title>
    <url>%2F%E4%B9%94%E5%B8%83%E6%96%AF2005%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6%E6%BC%94%E8%AE%B2%E4%B8%AD%E8%8B%B1%E6%96%87%E5%85%A8%E6%96%87.html</url>
    <content type="text"><![CDATA[Stanford Report, June 14, 2005 ‘You’ve got to find what you love,’ Jobs says This is the text of the Commencement address by Steve Jobs, CEO of Apple Computer and of Pixar Animation Studios, delivered on June 12, 2005. I am honored to be with you today at your commencement from one of the finest universities in the world. I never graduated from college. Truth be told, this is the closest I’ve ever gotten to a college graduation. Today I want to tell you three stories from my life. That’s it. No big deal. Just three stories. The first story is about connecting the dots. I dropped out of Reed College after the first 6 months, but then stayed around as a drop-in for another 18 months or so before I really quit. So why did I drop out? It started before I was born. My biological mother was a young, unwed college graduate student, and she decided to put me up for adoption. She felt very strongly that I should be adopted by college graduates, so everything was all set for me to be adopted at birth by a lawyer and his wife. Except that when I popped out they decided at the last minute that they really wanted a girl. So my parents, who were on a waiting list, got a call in the middle of the night asking: “We have an unexpected baby boy; do you want him?” They said: “Of course.” My biological mother later found out that my mother had never graduated from college and that my father had never graduated from high school. She refused to sign the final adoption papers. She only relented a few months later when my parents promised that I would someday go to college. And 17 years later I did go to college. But I naively chose a college that was almost as expensive as Stanford, and all of my working-class parents’ savings were being spent on my college tuition. After six months, I couldn’t see the value in it. I had no idea what I wanted to do with my life and no idea how college was going to help me figure it out. And here I was spending all of the money my parents had saved their entire life. So I decided to drop out and trust that it would all work out OK. It was pretty scary at the time, but looking back it was one of the best decisions I ever made. The minute I dropped out I could stop taking the required classes that didn’t interest me, and begin dropping in on the ones that looked interesting. It wasn’t all romantic. I didn’t have a dorm room, so I slept on the floor in friends’ rooms, I returned coke bottles for the 5?? deposits to buy food with, and I would walk the 7 miles across town every Sunday night to get one good meal a week at the Hare Krishna temple. I loved it. And much of what I stumbled into by following my curiosity and intuition turned out to be priceless later on. Let me give you one example: Reed College at that time offered perhaps the best calligraphy instruction in the country. Throughout the campus every poster, every label on every drawer, was beautifully hand calligraphed. Because I had dropped out and didn’t have to take the normal classes, I decided to take a calligraphy class to learn how to do this. I learned about serif and san serif typefaces, about varying the amount of space between different letter combinations, about what makes great typography great. It was beautiful, historical, artistically subtle in a way that science can’t capture, and I found it fascinating. None of this had even a hope of any practical application in my life. But ten years later, when we were designing the first Macintosh computer, it all came back to me. And we designed it all into the Mac. It was the first computer with beautiful typography. If I had never dropped in on that single course in college, the Mac would have never had multiple typefaces or proportionally spaced fonts. And since Windows just copied the Mac, its likely that no personal computer would have them. If I had never dropped out, I would have never dropped in on this calligraphy class, and personal computers might not have the wonderful typography that they do. Of course it was impossible to connect the dots looking forward when I was in college. But it was very, very clear looking backwards ten years later. Again, you can’t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future. You have to trust in something - your gut, destiny, life, karma, whatever. This approach has never let me down, and it has made all the difference in my life. My second story is about love and loss. I was lucky - I found what I loved to do early in life. Woz and I started Apple in my parents garage when I was 20. We worked hard, and in 10 years Apple had grown from just the two of us in a garage into a $2 billion company with over 4000 employees. We had just released our finest creation - the Macintosh - a year earlier, and I had just turned 30. And then I got fired. How can you get fired from a company you started? Well, as Apple grew we hired someone who I thought was very talented to run the company with me, and for the first year or so things went well. But then our visions of the future began to diverge and eventually we had a falling out. When we did, our Board of Directors sided with him. So at 30 I was out. And very publicly out. What had been the focus of my entire adult life was gone, and it was devastating. I really didn’t know what to do for a few months. I felt that I had let the previous generation of entrepreneurs down - that I had dropped the baton as it was being passed to me. I met with David Packard and Bob Noyce and tried to apologize for screwing up so badly. I was a very public failure, and I even thought about running away from the valley. But something slowly began to dawn on me - I still loved what I did. The turn of events at Apple had not changed that one bit. I had been rejected, but I was still in love. And so I decided to start over. I didn’t see it then, but it turned out that getting fired from Apple was the best thing that could have ever happened to me. The heaviness of being successful was replaced by the lightness of being a beginner again, less sure about everything. It freed me to enter one of the most creative periods of my life. During the next five years, I started a company named NeXT, another company named Pixar, and fell in love with an amazing woman who would become my wife. Pixar went on to create the worlds first computer animated feature film, Toy Story, and is now the most successful animation studio in the world. In a remarkable turn of events, Apple bought NeXT, I retuned to Apple, and the technology we developed at NeXT is at the heart of Apple’s current renaissance. And Laurene and I have a wonderful family together. I’m pretty sure none of this would have happened if I hadn’t been fired from Apple. It was awful tasting medicine, but I guess the patient needed it. Sometimes life hits you in the head with a brick. Don’t lose faith. I’m convinced that the only thing that kept me going was that I loved what I did. You’ve got to find what you love. And that is as true for your work as it is for your lovers. Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do. If you haven’t found it yet, keep looking. Don’t settle. As with all matters of the heart, you’ll know when you find it. And, like any great relationship, it just gets better and better as the years roll on. So keep looking until you find it. Don’t settle. My third story is about death. When I was 17, I read a quote that went something like: “If you live each day as if it was your last, someday you’ll most certainly be right.” It made an impression on me, and since then, for the past 33 years, I have looked in the mirror every morning and asked myself: “If today were the last day of my life, would I want to do what I am about to do today?” And whenever the answer has been “No” for too many days in a row, I know I need to change something. Remembering that I’ll be dead soon is the most important tool I’ve ever encountered to help me make the big choices in life. Because almost everything - all external expectations, all pride, all fear of embarrassment or failure - these things just fall away in the face of death, leaving only what is truly important. Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose. You are already naked. There is no reason not to follow your heart. About a year ago I was diagnosed with cancer. I had a scan at 7:30 in the morning, and it clearly showed a tumor on my pancreas. I didn’t even know what a pancreas was. The doctors told me this was almost certainly a type of cancer that is incurable, and that I should expect to live no longer than three to six months. My doctor advised me to go home and get my affairs in order, which is doctor’s code for prepare to die. It means to try to tell your kids everything you thought you’d have the next 10 years to tell them in just a few months. It means to make sure everything is buttoned up so that it will be as easy as possible for your family. It means to say your goodbyes. I lived with that diagnosis all day. Later that evening I had a biopsy, where they stuck an endoscope down my throat, through my stomach and into my intestines, put a needle into my pancreas and got a few cells from the tumor. I was sedated, but my wife, who was there, told me that when they viewed the cells under a microscope the doctors started crying because it turned out to be a very rare form of pancreatic cancer that is curable with surgery. I had the surgery and I’m fine now. This was the closest I’ve been to facing death, and I hope its the closest I get for a few more decades. Having lived through it, I can now say this to you with a bit more certainty than when death was a useful but purely intellectual concept: No one wants to die. Even people who want to go to heaven don’t want to die to get there. And yet death is the destination we all share. No one has ever escaped it. And that is as it should be, because Death is very likely the single best invention of Life. It is Life’s change agent. It clears out the old to make way for the new. Right now the new is you, but someday not too long from now, you will gradually become the old and be cleared away. Sorry to be so dramatic, but it is quite true. Your time is limited, so don’t waste it living someone else’s life. Don’t be trapped by dogma - which is living with the results of other people’s thinking. Don’t let the noise of other’s opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary. When I was young, there was an amazing publication called The Whole Earth Catalog, which was one of the bibles of my generation. It was created by a fellow named Stewart Brand not far from here in Menlo Park, and he brought it to life with his poetic touch. This was in the late 1960’s, before personal computers and desktop publishing, so it was all made with typewriters, scissors, and polaroid cameras. It was sort of like Google in paperback form, 35 years before Google came along: it was idealistic, and overflowing with neat tools and great notions. Stewart and his team put out several issues of The Whole Earth Catalog, and then when it had run its course, they put out a final issue. It was the mid-1970s, and I was your age. On the back cover of their final issue was a photograph of an early morning country road, the kind you might find yourself hitchhiking on if you were so adventurous. Beneath it were the words: “Stay Hungry. Stay Foolish.” It was their farewell message as they signed off. Stay Hungry. Stay Foolish. And I have always wished that for myself. And now, as you graduate to begin anew, I wish that for you. Stay Hungry. Stay Foolish. Thank you all very much. Steve Jobs说，你得找出你爱的 (You’ve got to find what you love.)。 以下是苹果计算机公司与Pixar动画制作室执行长Steve Jobs在2005年六月12日对全体史丹佛大学毕业生的演讲内容。 今天，有荣幸来到各位从世界上最好的学校之一毕业的毕业典礼上。我从来没从大学毕业。说实话，这是我离大学毕业最近的一刻。今天，我只说三个故事，不谈大道理，三个故事就好。 第一个故事，是关于人生中的点点滴滴怎么串连在一起。 我在里德学院（Reed college）待了六个月就办休学了。到我退学前，一共休学了十八个月。那么，我为什么休学？ 这得从我出生前讲起。我的亲生母亲当时是个研究生，年轻未婚妈妈，她决定让别人收养我。她强烈觉得应该让有大学毕业的人收养我，所以我出生时，她就准备让我被一对律师夫妇收养。但是这对夫妻到了最后一刻反悔了，他们想收养女孩。所以在等待收养名单上的一对夫妻，我的养父母，在一天半夜里接到一通电话，问他们「有一名意外出生的男孩，你们要认养他吗？」而他们的回答是「当然要」。后来，我的生母发现，我现在的妈妈从来没有大学毕业，我现在的爸爸则连高中毕业也没有。她拒绝在认养文件上做最后签字。直到几个月后，我的养父母同意将来一定会让我上大学，她才软化态度。 十七年后，我上大学了。但是当时我无知选了一所学费几乎跟史丹佛一样贵的大学，我那工人阶级的父母所有积蓄都花在我的学费上。六个月后，我看不出念这个书的价值何在。那时候，我不知道这辈子要干什么，也不知道念大学能对我有什么帮助，而且我为了念这个书，花光了我父母这辈子的所有积蓄，所以我决定休学，相信船到桥头自然直。当时这个决定看来相当可怕，可是现在看来，那是我这辈子做过最好的决定之一。当我休学之后，我再也不用上我没兴趣的必修课，把时间拿去听那些我有兴趣的课。 这一点也不浪漫。我没有宿舍，所以我睡在友人家里的地板上，靠着回收可乐空罐的五先令退费买吃的，每个星期天晚上得走七里的路绕过大半个镇去印度教的 Hare Krishna神庙吃顿好料。我喜欢Hare Krishna神庙的好料。追寻我的好奇与直觉，我所驻足的大部分事物，后来看来都成了无价之宝。举例来说： 当时里德学院有着大概是全国最好的书法指导。在整个校园内的每一张海报上，每个抽屉的标签上，都是美丽的手写字。因为我休学了，可以不照正常选课程序来，所以我跑去学书法。我学了serif与san serif字体，学到在不同字母组合间变更字间距，学到活版印刷伟大的地方。书法的美好、历史感与艺术感是科学所无法捕捉的，我觉得那很迷人。 我没预期过学的这些东西能在我生活中起些什么实际作用，不过十年后，当我在设计第一台麦金塔时，我想起了当时所学的东西，所以把这些东西都设计进了麦金塔里，这是第一台能印刷出漂亮东西的计算机。如果我没沉溺于那样一门课里，麦金塔可能就不会有多重字体跟变间距字体了。又因为Windows抄袭了麦金塔的使用方式，如果当年我没这样做，大概世界上所有的个人计算机都不会有这些东西，印不出现在我们看到的漂亮的字来了。当然，当我还在大学里时，不可能把这些点点滴滴预先串在一起，但是这在十年后回顾，就显得非常清楚。 我再说一次，你不能预先把点点滴滴串在一起；唯有未来回顾时，你才会明白那些点点滴滴是如何串在一起的。所以你得相信，你现在所体会的东西，将来多少会连接在一块。你得信任某个东西，直觉也好，命运也好，生命也好，或者业力。这种作法从来没让我失望，也让我的人生整个不同起来。 我的第二个故事，有关爱与失去。 我好运－年轻时就发现自己爱做什么事。我二十岁时，跟Steve Wozniak在我爸妈的车库里开始了苹果计算机的事业。我们拼命工作，苹果计算机在十年间从一间车库里的两个小伙子扩展成了一家员工超过四千人、市价二十亿美金的公司，在那之前一年推出了我们最棒的作品－麦金塔，而我才刚迈入人生的第三十个年头，然后被炒鱿鱼。要怎么让自己创办的公司炒自己鱿鱼？好吧，当苹果计算机成长后，我请了一个我以为他在经营公司上很有才干的家伙来，他在头几年也确实干得不错。可是我们对未来的愿景不同，最后只好分道扬镳，董事会站在他那边，炒了我鱿鱼，公开把我请了出去。曾经是我整个成年生活重心的东西不见了，令我不知所措。 有几个月，我实在不知道要干什么好。我觉得我令企业界的前辈们失望－我把他们交给我的接力棒弄丢了。我见了创办HP的David Packard跟创办Intel的Bob Noyce，跟他们说我很抱歉把事情搞砸得很厉害了。我成了公众的非常负面示范，我甚至想要离开硅谷。但是渐渐的，我发现，我还是喜爱着我做过的事情，在苹果的日子经历的事件没有丝毫改变我爱做的事。我被否定了，可是我还是爱做那些事情，所以我决定从头来过。 当时我没发现，但是现在看来，被苹果计算机开除，是我所经历过最好的事情。成功的沉重被从头来过的轻松所取代，每件事情都不那么确定，让我自由进入这辈子最有创意的年代。 接下来五年，我开了一家叫做NeXT的公司，又开一家叫做Pixar的公司，也跟后来的老婆谈起了恋爱。Pixar接着制作了世界上第一部全计算机动画电影，玩具总动员，现在是世界上最成功的动画制作公司。然后，苹果计算机买下了NeXT，我回到了苹果，我们在NeXT发展的技术成了苹果计算机后来复兴的核心。我也有了个美妙的家庭。 我很确定，如果当年苹果计算机没开除我，就不会发生这些事情。这帖药很苦口，可是我想苹果计算机这个病人需要这帖药。有时候，人生会用砖头打你的头。不要丧失信心。我确信，我爱我所做的事情，这就是这些年来让我继续走下去的唯一理由。你得找出你爱的，工作上是如此，对情人也是如此。你的工作将填满你的一大块人生，唯一获得真正满足的方法就是做你相信是伟大的工作，而唯一做伟大工作的方法是爱你所做的事。如果你还没找到这些事，继续找，别停顿。尽你全心全力，你知道你一定会找到。而且，如同任何伟大的关系，事情只会随着时间愈来愈好。所以，在你找到之前，继续找，别停顿。 我的第三个故事，关于死亡。 当我十七岁时，我读到一则格言，好像是「把每一天都当成生命中的最后一天，你就会轻松自在。」这对我影响深远，在过去33年里，我每天早上都会照镜子，自问：「如果今天是此生最后一日，我今天要干些什么？」每当我连续太多天都得到一个「没事做」的答案时，我就知道我必须有所变革了。 提醒自己快死了，是我在人生中下重大决定时，所用过最重要的工具。因为几乎每件事－所有外界期望、所有名誉、所有对困窘或失败的恐惧－在面对死亡时，都消失了，只有最重要的东西才会留下。提醒自己快死了，是我所知避免掉入自己有东西要失去了的陷阱里最好的方法。人生不带来，死不带去，没什么道理不顺心而为。 一年前，我被诊断出癌症。我在早上七点半作断层扫描，在胰脏清楚出现一个肿瘤，我连胰脏是什么都不知道。医生告诉我，那几乎可以确定是一种不治之症，我大概活不到三到六个月了。医生建议我回家，好好跟亲人们聚一聚，这是医生对临终病人的标准建议。那代表你得试着在几个月内把你将来十年想跟小孩讲的话讲完。那代表你得把每件事情搞定，家人才会尽量轻松。那代表你得跟人说再见了。 我整天想着那个诊断结果，那天晚上做了一次切片，从喉咙伸入一个内视镜，从胃进肠子，插了根针进胰脏，取了一些肿瘤细胞出来。我打了镇静剂，不醒人事，但是我老婆在场。她后来跟我说，当医生们用显微镜看过那些细胞后，他们都哭了，因为那是非常少见的一种胰脏癌，可以用手术治好。所以我接受了手术，康复了。 这是我最接近死亡的时候，我希望那会继续是未来几十年内最接近的一次。经历此事后，我可以比之前死亡只是抽象概念时要更肯定告诉你们下面这些： 没有人想死。即使那些想上天堂的人，也想活着上天堂。但是死亡是我们共有的目的地，没有人逃得过。这是注定的，因为死亡简直就是生命中最棒的发明，是生命变化的媒介，送走老人们，给新生代留下空间。现在你们是新生代，但是不久的将来，你们也会逐渐变老，被送出人生的舞台。抱歉讲得这么戏剧化，但是这是真的。 你们的时间有限，所以不要浪费时间活在别人的生活里。不要被信条所惑－盲从信条就是活在别人思考结果里。不要让别人的意见淹没了你内在的心声。最重要的，拥有跟随内心与直觉的勇气，你的内心与直觉多少已经知道你真正想要成为什么样的人。任何其它事物都是次要的。 在我年轻时，有本神奇的杂志叫做Whole Earth Catalog，当年我们很迷这本杂志。那是一位住在离这不远的Menlo Park的Stewart Brand发行的，他把杂志办得很有诗意。那是1960年代末期，个人计算机跟桌上出版还没发明，所有内容都是打字机、剪刀跟拍立得相机做出来的。杂志内容有点像印在纸上的Google，在Google出现之前35年就有了：理想化，充满新奇工具与神奇的注记。 Stewart跟他的出版团队出了好几期Whole Earth Catalog，然后出了停刊号。当时是1970年代中期，我正是你们现在这个年龄的时候。在停刊号的封底，有张早晨乡间小路的照片，那种你去爬山时会经过的乡间小路。在照片下有行小字： 求知若饥，虚心若愚。 那是他们亲笔写下的告别讯息，我总是以此自许。当你们毕业，展开新生活，我也以此期许你们。 求知若饥，虚心若愚。 非常谢谢大家。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>乔布斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斯诺克的起源于发展]]></title>
    <url>%2F%E6%96%AF%E8%AF%BA%E5%85%8B%E7%9A%84%E8%B5%B7%E6%BA%90%E4%BA%8E%E5%8F%91%E5%B1%95.html</url>
    <content type="text"><![CDATA[斯诺克的起源关于台球的诞生，众说纷纭，较为公认的说法，大概是起源于14或15世纪的西欧。 斯诺克，是台球运动发展过程中演变出的多种形式之一。直到19世纪，斯诺克才在英国某个陆军军队问世，并很快流行开来。斯诺克一词是当时英国军队中对军校一年级新生的流行叫法。这使得斯诺克被这些军人们用来称呼这种新玩法的初学者，最终则成为了这项运动的名称。 斯诺克的发展1927年，在现代斯诺克台球之父乔·戴维斯等人的努力下，于伦敦举办了第一届斯诺克世界职业锦标赛，戴维斯本人也获得了冠军。 1950-1969年，斯诺克的发展陷入低潮，中间许多年份甚至没有任何锦标赛举行。知道1969年，BBC举行的Pot Black锦标赛才将人们的视线重新吸引到斯诺克上来。 几年之后，电视转播斯诺克锦标赛大大地推进了斯诺克的发展，使其成为一项主流的职业运动。1977年，斯诺克引入了世界职业选手排名。 1982年，天然金块史蒂夫·戴维斯打出了历史上首个电视转播中的147分的满分杆。80年代涌现出了一批优秀的斯诺克球手，在外界资金的注入下，斯诺克的发展进入了黄金时期。可以说，80年代是斯诺克发展史上的少年期和青年期的分水岭。 到了90年代，斯诺克已然步入青年，打法也更为现代。台球皇帝史蒂芬·亨得利在整个90年代几乎掌控了斯诺克界。75三杰也冉冉升起，接过皇帝的神杖，统治了斯诺克界。75三杰与皇帝一起创造了四大天王的梦幻时代。 斯诺克的现在与未来用一个词来形容现在的斯诺克界，可谓“豪强并起”。这项运动越来越普及，水平也越来越高。像皇帝那样统治斯诺克界的时代一去不返了，这是一个群雄逐鹿的时代，这是斯诺克蓬勃发展的时代。 未来，斯诺克进入奥运会只是时间上的问题，斯诺克的普及是可以预见的。让我们一起期待斯诺克新的“黄金时代”。]]></content>
      <categories>
        <category>snooker</category>
      </categories>
      <tags>
        <tag>snooker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客迁移记]]></title>
    <url>%2F%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AE%B0.html</url>
    <content type="text"><![CDATA[几年前就折腾过一个 keisme.com 的域名，也是用的 hexo + github 搭建的，后来没有维护，域名也过期了。现在想重新拾起，发现域名已被注册，只好注册了现在的这个域名 keisme.cn，又折腾了一阵子，才有了现在这个站点。 其实比较懒，一直没有写作的习惯，如今年岁渐长，愈发觉得时光过得飞快，回忆往昔，只觉如梦一场，竟想不起过去的许多事，而文字能记下一些点滴，于是决定坚持写下去。这大半年算是养成了写东西的习惯，有的公诸网络，有的私下琐记。 现在有了这个新的角落，自然想把以前写的一些杂乱文章搬过来，却不能尽数迁移，只好选择其中一部分作为保留。 恩，差不多就是这样。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
</search>
